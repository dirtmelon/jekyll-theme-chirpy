<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="URL-loading-system" /><meta name="author" content="dirtmelon" /><meta property="og:locale" content="en_US" /><meta name="description" content="原文：[URL Loading System Apple Developer Documentation](https://developer.apple.com/documentation/foundation/url_loading_system)" /><meta property="og:description" content="原文：[URL Loading System Apple Developer Documentation](https://developer.apple.com/documentation/foundation/url_loading_system)" /><link rel="canonical" href="https://dirtmelon.github.io/posts/url-loading-system/" /><meta property="og:url" content="https://dirtmelon.github.io/posts/url-loading-system/" /><meta property="og:site_name" content="Dirtmelon" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2019-11-30T16:24:54+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="URL-loading-system" /><meta name="twitter:site" content="@Dirt_melon" /><meta name="twitter:creator" content="@dirtmelon" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"dirtmelon"},"description":"原文：[URL Loading System Apple Developer Documentation](https://developer.apple.com/documentation/foundation/url_loading_system)","url":"https://dirtmelon.github.io/posts/url-loading-system/","headline":"URL-loading-system","dateModified":"2019-11-30T16:24:54+08:00","datePublished":"2019-11-30T16:24:54+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://dirtmelon.github.io/posts/url-loading-system/"},"@type":"BlogPosting","@context":"https://schema.org"}</script><title>URL-loading-system | Dirtmelon</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Dirtmelon"><meta name="application-name" content="Dirtmelon"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/favicons/apple-icon.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Dirtmelon</a></div><div class="site-subtitle font-italic">Dirtmelon's blog</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/dirtmelon" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/Dirt_melon" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['0xffdirtmelon','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>URL-loading-system</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>URL-loading-system</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> dirtmelon </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sat, Nov 30, 2019, 4:24 PM +0800" prep="on" > Nov 30, 2019 <i class="unloaded">2019-11-30T16:24:54+08:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="9966 words">55 min</span></div></div><div class="post-content"><div class="table-wrapper"><table><tbody><tr><td>原文：[URL Loading System<td>Apple Developer Documentation](https://developer.apple.com/documentation/foundation/url_loading_system)</table></div><p>通过标准的互联网协议来与 URL 交流和与服务器通讯。</p><h2 id="概览">概览</h2><p>URL Loading System 可以获取通过 URL 来辨别的资源，使用如 https 的标准协议或者一些你创造的自定义协议。加载是异步执行的，所以你的应用可以继续响应操作和在返回数据或者错误时进行处理。 你可以使用 <a href="https://developer.apple.com/documentation/foundation/urlsession">URLSession</a> 对象来创建一个或者多个 <a href="https://developer.apple.com/documentation/foundation/urlsessiontask">URLSessionTask</a> 对象，<code class="language-plaintext highlighter-rouge">URLSessionTask</code> 可以抓取和返回数据，下载文件，或者上传数据和文件到服务器。你可以使用 <a href="https://developer.apple.com/documentation/foundation/urlsessionconfiguration">URLSessionConfiguration</a> 来配置会话（session），它可以控制像如何使用缓存和 cookies ，是否允许在蜂窝网络下进行连接等行为。</p><p>你可以使用一个会话来重复创建任务（tasks）。举个例子，一个浏览器可以有不同的会话提供给标准模式和隐私模式使用，隐私模式的会话不缓存数据。下图表示了两个会话如何通过 configuration 来创建多个任务。</p><p><img data-proofer-ignore data-src="/media/6789dd96-afdc-4c18-b8eb-01f9012dc04d.png" alt="6789dd96-afdc-4c18-b8eb-01f9012dc04d" /></p><p>每个会话都与一个 delegate 相关联，通过 delegate 来接收时而出现的更新（或者错误）。默认的 delegate 会调用你提供的 completion handler block，如果你选择提供自定义的 delegate，那么 block 就不会执行。</p><p>你可以配置一个会话在后台运行，所以当你的 app 退到后台时，系统可以下载数据并唤醒 app 来接收数据。</p><h2 id="获取网络数据到内存中">获取网络数据到内存中</h2><p>URL session 通过创建一个数据任务来获取数据到内存中。</p><h3 id="概览-1">概览</h3><p>当与服务器进行一些较轻量的连接时，你可以使用 <a href="https://developer.apple.com/documentation/foundation/urlsessiondatatask">URLSessionDataTask</a> 来获取数据到内存中（<a href="https://developer.apple.com/documentation/foundation/urlsessiondownloadtask">URLSessionDownloadTask</a> 则是用来存取数据到文件系统中）。<code class="language-plaintext highlighter-rouge">URLSessionDataTask</code> 非常适用于调用 Web 服务。</p><p>你可以使用一个 <code class="language-plaintext highlighter-rouge">URLSession</code> 对象来创建一个 任务 。如果你的需求很简单，你可以使用 <a href="https://developer.apple.com/documentation/foundation/urlsession/1409000-shared">shared</a> 对象。如果你想通过 delegate 回调和传输进行交互，那么你需要创建一个 <code class="language-plaintext highlighter-rouge">URLSession</code> 对象，而不是使用 <code class="language-plaintext highlighter-rouge">shared</code> 对象。当创建 <code class="language-plaintext highlighter-rouge">URLSession</code> 时，你可以使用 <a href="https://developer.apple.com/documentation/foundation/urlsessionconfiguration">URLSessionConfiguration</a> 对象来进行配置，同时也可以给 <code class="language-plaintext highlighter-rouge">URLSession</code> 设置遵循了 <a href="https://developer.apple.com/documentation/foundation/urlsessiondelegate">URLSessionDelegate</a> 协议或者它的子协议的类作为 delegate 。可以重复使用 <code class="language-plaintext highlighter-rouge">URLSession</code> 来创建多个 任务 ，因此对于所需的每个唯一配置，请创建一个 <code class="language-plaintext highlighter-rouge">URLSession</code> ，并将其存储为属性。</p><blockquote><p>注意 不要创建多余的 <code class="language-plaintext highlighter-rouge">URLSession</code> 。举个例子，如果你的 app 不同的部分需要一个相似配置的 <code class="language-plaintext highlighter-rouge">URLSession</code> ，创建一个 <code class="language-plaintext highlighter-rouge">URLSession</code> 并进行共享。</p></blockquote><p>当你已有一个 <code class="language-plaintext highlighter-rouge">URLSession</code> ，你可以通过一个 <code class="language-plaintext highlighter-rouge">dataTask()</code> 方法来创建一个数据任务。 任务被创建时是处于被挂起状态，可以通过调用 <a href="https://developer.apple.com/documentation/foundation/urlsessiontask/1411121-resume">resume()</a> 来启动任务。</p><h3 id="通过-completion-handler-来接收结果">通过 Completion Handler 来接收结果</h3><p>获取数据最简单的方法是创建一个使用 completion handler 的数据任务。通过这种安排，任务将服务器的响应，数据以及可能的错误传递到你提供的 completion handler。下图显示了会话和任务之间的关系，以及如何将结果传递到 completion handler。</p><p><img data-proofer-ignore data-src="/media/bf4501ff-82b2-4dd4-9ec3-243ef0e70d21.png" alt="bf4501ff-82b2-4dd4-9ec3-243ef0e70d21" /></p><p>通过调用 <code class="language-plaintext highlighter-rouge">URLSession</code> 的 <a href="https://developer.apple.com/documentation/foundation/urlsession/1411554-datatask">dataTask(with:)</a> 方法可以创建一个使用 completion handler 的数据任务。你的 completion handler 需要处理以下3件事：</p><ol><li>验证错误参数是否为空。如果不是，则说明发生了传输错误，处理错误并退出。<li>检查响应参数以验证状态码是否为成功的状态码，且MIME类型是期望值。如果不是，处理服务器错误并退出。<li>根据需要使用数据对象</ol><p>以下代码展示了如何使用 <code class="language-plaintext highlighter-rouge">startLoad()</code> 方法来获取一个 URL 的内容。首先使用<code class="language-plaintext highlighter-rouge">URLSession</code> 的 <code class="language-plaintext highlighter-rouge">shared</code> 对象创建一个数据任务，将其结果传递给 completion handler 。在检查本地和服务器错误后，将数据转换为字符串，并使用 <code class="language-plaintext highlighter-rouge">WKWebView</code> 来进行加载。当然，你的应用程序可能还有其他用途来获取数据，例如将其解析为数据模型。</p><pre><code class="language-Swift">func startLoad() {
    let url = URL(string: "https://www.example.com/")!
    let task = URLSession.shared.dataTask(with: url) { data, response, error in
        if let error = error {
            self.handleClientError(error)
            return
        }
        guard let httpResponse = response as? HTTPURLResponse,
            (200...299).contains(httpResponse.statusCode) else {
            self.handleServerError(response)
            return
        }
        if let mimeType = httpResponse.mimeType, mimeType == "text/html",
            let data = data,
            let string = String(data: data, encoding: .utf8) {
            DispatchQueue.main.async {
                self.webView.loadHTMLString(string, baseURL: url)
            }
        }
    }
    task.resume()
}
</code></pre><blockquote><p>重要 completion handler 是在不同的 GCD 队列中调用。因此如果需要更新 UI ，则需要明确地指出是在主队列中调用。</p></blockquote><h3 id="通过-delegate-来接收详细信息和结果">通过 delegate 来接收详细信息和结果</h3><p>为了在执行任务活动时获得更高级别的访问权限，在创建数据任务时，您可以在会话上设置 delegate ，而不是提供 completion handler 。下图展示了这种做法。</p><p><img data-proofer-ignore data-src="/media/730c8e1b-654f-4eb9-9c63-d439a69ac5d2.png" alt="730c8e1b-654f-4eb9-9c63-d439a69ac5d2" /></p><p>通过这种方法，部分数据在到达时会调用 <a href="https://developer.apple.com/documentation/foundation/urlsessiondatadelegate">URLSessionDataDelegate</a> 的<a href="https://developer.apple.com/documentation/foundation/urlsessiondatadelegate/1411528-urlsession">urlSession(_:dataTask:didReceive:)</a> 方法，直到传输完成或出现错误。随着任务的进行，delegate 还接收其他类型的事件。</p><p>使用 delgate 模式时，您需要创建自己的 <code class="language-plaintext highlighter-rouge">URLSession</code> 对象，而不是使用 <code class="language-plaintext highlighter-rouge">URLSession</code> 的 <code class="language-plaintext highlighter-rouge">shared</code> 对象。创建一个新的会话允许你将自己的类设置为会话的 delegate ，如下面代码所示。</p><div lang="swift" class="language-swift highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kd">private</span> <span class="kd">lazy</span> <span class="k">var</span> <span class="nv">session</span><span class="p">:</span> <span class="kt">URLSession</span> <span class="o">=</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">configuration</span> <span class="o">=</span> <span class="kt">URLSessionConfiguration</span><span class="o">.</span><span class="k">default</span>
    <span class="n">configuration</span><span class="o">.</span><span class="n">waitsForConnectivity</span> <span class="o">=</span> <span class="kc">true</span>
    <span class="k">return</span> <span class="kt">URLSession</span><span class="p">(</span><span class="nv">configuration</span><span class="p">:</span> <span class="n">configuration</span><span class="p">,</span>
                      <span class="nv">delegate</span><span class="p">:</span> <span class="k">self</span><span class="p">,</span> <span class="nv">delegateQueue</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>
<span class="p">}()</span>
</pre></table></code></div></div><p>声明你的类实现了一个或多个委托协议（<a href="https://developer.apple.com/documentation/foundation/urlsessiondelegate">URLSessionDelegate</a> ，<a href="https://developer.apple.com/documentation/foundation/urlsessiontaskdelegate">URLSessionTaskDelegate</a> ，<a href="https://developer.apple.com/documentation/foundation/urlsessiondatadelegate">URLSessionDataDelegate</a> 和<a href="https://developer.apple.com/documentation/foundation/urlsessiondownloaddelegate">URLSessionDownloadDelegate</a> ）。然后通过 <a href="https://developer.apple.com/documentation/foundation/urlsession/1411597-init">init(configuration:delegate:delegateQueue:)</a> 创建 URL 会话对象。你可以定制对应的配置对象。例如，将 <code class="language-plaintext highlighter-rouge">waitsForConnectivity</code> 设置为 <code class="language-plaintext highlighter-rouge">true</code> 是个好想法。这样，会话将等待适当的连接，而不是在所需的连接不可用时立即失败。</p><p>下面代码展示了 <code class="language-plaintext highlighter-rouge">startLoad()</code> 方法是如何使用会话来启动数据任务，和使用 delegate 的回调方法来处理接收到的数据和错误。下面代码实现了三个 delegate 的回调方法：</p><ul><li><a href="https://developer.apple.com/documentation/foundation/urlsessiondatadelegate/1410027-urlsession">urlSession(_:dataTask:didReceive:completionHandler:)</a> 验证响应是否具有成功的 HTTP 状态代码，且 MIME 类型为 text/html 或 text/plain。如果这两种情况都不是，则取消任务，否则可以继续进行任务。<li><a href="https://developer.apple.com/documentation/foundation/urlsessiondatadelegate/1411528-urlsession">urlSession(_:dataTask:didReceive:)</a> 处理任务接收到的每个数据对象，并将其添加 <code class="language-plaintext highlighter-rouge">receivedData</code> 的缓冲区中。<li><a href="https://developer.apple.com/documentation/foundation/urlsessiontaskdelegate/1411610-urlsession">urlSession(_:task:didCompleteWithError:)</a> 首先查看是否发生了传输级的错误。如果没有错误，就尝试将 <code class="language-plaintext highlighter-rouge">receivedData</code> 缓冲区转换为字符串并设置为 webView 的内容。</ul><div lang="swift" class="language-swift highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre><td class="rouge-code"><pre><span class="k">var</span> <span class="nv">receivedData</span><span class="p">:</span> <span class="kt">Data</span><span class="p">?</span>

<span class="kd">func</span> <span class="nf">startLoad</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">loadButton</span><span class="o">.</span><span class="n">isEnabled</span> <span class="o">=</span> <span class="kc">false</span>
    <span class="k">let</span> <span class="nv">url</span> <span class="o">=</span> <span class="kt">URL</span><span class="p">(</span><span class="nv">string</span><span class="p">:</span> <span class="s">"https://www.example.com/"</span><span class="p">)</span><span class="o">!</span>
    <span class="n">receivedData</span> <span class="o">=</span> <span class="kt">Data</span><span class="p">()</span>
    <span class="k">let</span> <span class="nv">task</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="nf">dataTask</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">url</span><span class="p">)</span>
    <span class="n">task</span><span class="o">.</span><span class="nf">resume</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// delegate methods</span>

<span class="kd">func</span> <span class="nf">urlSession</span><span class="p">(</span><span class="n">_</span> <span class="nv">session</span><span class="p">:</span> <span class="kt">URLSession</span><span class="p">,</span> <span class="nv">dataTask</span><span class="p">:</span> <span class="kt">URLSessionDataTask</span><span class="p">,</span> <span class="n">didReceive</span> <span class="nv">response</span><span class="p">:</span> <span class="kt">URLResponse</span><span class="p">,</span>
                <span class="nv">completionHandler</span><span class="p">:</span> <span class="kd">@escaping</span> <span class="p">(</span><span class="kt">URLSession</span><span class="o">.</span><span class="kt">ResponseDisposition</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Void</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">guard</span> <span class="k">let</span> <span class="nv">response</span> <span class="o">=</span> <span class="n">response</span> <span class="k">as?</span> <span class="kt">HTTPURLResponse</span><span class="p">,</span>
        <span class="p">(</span><span class="mi">200</span><span class="o">...</span><span class="mi">299</span><span class="p">)</span><span class="o">.</span><span class="nf">contains</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">statusCode</span><span class="p">),</span>
        <span class="k">let</span> <span class="nv">mimeType</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">mimeType</span><span class="p">,</span>
        <span class="n">mimeType</span> <span class="o">==</span> <span class="s">"text/html"</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nf">completionHandler</span><span class="p">(</span><span class="o">.</span><span class="n">cancel</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="nf">completionHandler</span><span class="p">(</span><span class="o">.</span><span class="n">allow</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">urlSession</span><span class="p">(</span><span class="n">_</span> <span class="nv">session</span><span class="p">:</span> <span class="kt">URLSession</span><span class="p">,</span> <span class="nv">dataTask</span><span class="p">:</span> <span class="kt">URLSessionDataTask</span><span class="p">,</span> <span class="n">didReceive</span> <span class="nv">data</span><span class="p">:</span> <span class="kt">Data</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">self</span><span class="o">.</span><span class="n">receivedData</span><span class="p">?</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">urlSession</span><span class="p">(</span><span class="n">_</span> <span class="nv">session</span><span class="p">:</span> <span class="kt">URLSession</span><span class="p">,</span> <span class="nv">task</span><span class="p">:</span> <span class="kt">URLSessionTask</span><span class="p">,</span> <span class="n">didCompleteWithError</span> <span class="nv">error</span><span class="p">:</span> <span class="kt">Error</span><span class="p">?)</span> <span class="p">{</span>
    <span class="kt">DispatchQueue</span><span class="o">.</span><span class="n">main</span><span class="o">.</span><span class="n">async</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">loadButton</span><span class="o">.</span><span class="n">isEnabled</span> <span class="o">=</span> <span class="kc">true</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nv">error</span> <span class="o">=</span> <span class="n">error</span> <span class="p">{</span>
            <span class="nf">handleClientError</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="k">let</span> <span class="nv">receivedData</span> <span class="o">=</span> <span class="k">self</span><span class="o">.</span><span class="n">receivedData</span><span class="p">,</span>
            <span class="k">let</span> <span class="nv">string</span> <span class="o">=</span> <span class="kt">String</span><span class="p">(</span><span class="nv">data</span><span class="p">:</span> <span class="n">receivedData</span><span class="p">,</span> <span class="nv">encoding</span><span class="p">:</span> <span class="o">.</span><span class="n">utf8</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">self</span><span class="o">.</span><span class="n">webView</span><span class="o">.</span><span class="nf">loadHTMLString</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="nv">baseURL</span><span class="p">:</span> <span class="n">task</span><span class="o">.</span><span class="n">currentRequest</span><span class="p">?</span><span class="o">.</span><span class="n">url</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>各种 delegate 提供的方法除了上述代码中所示的方法之外，还用于处理身份验证挑战，重定向和其他特殊情况。在 <code class="language-plaintext highlighter-rouge">URLSession</code> 讨论中，使用 URL 会话描述了在传输过程中可能发生的各种回调。</p><h2 id="nsurlsession">NSURLSession</h2><p>负责协调组织一组相关的网络数据传输任务</p><p><code class="language-plaintext highlighter-rouge">NSURLSession</code> 类和相关类提供了一个 API ，用于从 URL 指示的链接下载数据或将数据上传 。该 API 还可以使你的应用在后台或处于暂停状态时执行后台下载。丰富的 delegate 方法支持身份验证，并允许你的应用收到有关重定向等事件的通知。</p><h3 id="会话类型">会话类型</h3><p>拥有相同会话的任务会分享一个共同的会话配置，配置定义了连接的行为，如最大连接数，是否允许使用蜂窝网络等。</p><p><code class="language-plaintext highlighter-rouge">NSURLSession</code> 有用于基本请求的单例 <code class="language-plaintext highlighter-rouge">sharedSession</code> （没有配置对象）。它不像你创建的会话那样可进行自定义，如果你的要求不多，可以尝试下使用它。也可以通过下面三种配置来进行初始化：</p><ol><li>default session ： 跟 <code class="language-plaintext highlighter-rouge">sharedSession</code> 非常相似，但是允许你设置更多配置，并且可以通过 delegate 来增量获取数据。<li>ephemeral session ：临时会话，跟 <code class="language-plaintext highlighter-rouge">sharedSession</code> 的不同之处在于它不会将缓存，cookie或者认证凭证存储到硬盘中。<li>Background session ：允许你在后台执行上传或者下载任务</ol><h3 id="任务类型">任务类型</h3><p>在会话中，你创建的任务可以有选择地将数据上传到服务器，然后可以选择将接收到的数据转为文件存放到硬盘中还是转为 <code class="language-plaintext highlighter-rouge">NSData</code> 对象存放到内存中。 <code class="language-plaintext highlighter-rouge">NSURLSession</code> API 提供三种类型的任务：</p><ol><li>data task ：使用 <code class="language-plaintext highlighter-rouge">NSData</code> 对象来接收和发送数据。通常用于执行一些数据较小的，可与服务器进行交互的请求<li>upload task ：跟 data task 类似，但是通常用于上传文件形式的数据，支持后台上传<li>Download task ：以文件形式下载数据，支持后台下载</ol><h3 id="使用会话-delegate">使用会话 delegate</h3><p>会话的任务会共享 delegate ，delegate 允许你在各种事件发生时（如认证失败，接收到来自服务的数据，数据准备好缓存等）进行处理和获取信息。如果你不需要设置 delegate ，可以在创建会话时传递 nil 参数。</p><blockquote><p>重要 会话对象会强引用 delegate ，直到你的 app 退出或者显式终止会话。所以如果你不显式中止会话，那么就会有内存泄露。</p></blockquote><h3 id="会话和异步">会话和异步</h3><p>跟大多数网络 API 一样， <code class="language-plaintext highlighter-rouge">NSURLSession</code>也是高度异步的。它可以通过以下两种方式返回数据：</p><ul><li>通过在传输成功完成或出现错误时调用 completion handler。<li>在接收数据和传输完成时调用会话 delegate 的方法。</ul><p>同时 <code class="language-plaintext highlighter-rouge">NSURLSession</code> API 还提供了状态和进度属性，你可以根据任务当前的状态来进行决策（状态随时有可能改变）。</p><p><code class="language-plaintext highlighter-rouge">NSURLSession</code> 同时还是支持取消，重启，恢复和挂起任务，并提供从被中断处恢复已被挂起，取消或者下载失败的任务。</p><h3 id="支持的协议">支持的协议</h3><p><code class="language-plaintext highlighter-rouge">NSURLSession</code> 支持 data ， file ， ftp ， http ， 和 https 协议，并可以根据用户的系统偏好设置支持代理服务器和 socks 网关。</p><p>NSURLSession支持 HTTP/1.1 和 HTTP/2 协议。如 <a href="https://tools.ietf.org/html/rfc7540">RFC 7540</a> 所述，HTTP/2 支持需要服务器支持应用程序层协议协商（ALPN）。</p><p>还可以通过将 NSURLProtocol 子类化，添加对自己的自定义网络协议和 URL 方案的支持（应用私有）。</p><h3 id="app-transport-security-ats">App Transport Security (ATS)</h3><p>从 iOS 9.0 和 OS X 10.11 开始，默认情况下为使用 <code class="language-plaintext highlighter-rouge">NSURLSession</code> 建立的 HTTP 连接都启用 HTTPS (<a href="https://tools.ietf.org/html/rfc2818">RFC 2818</a>)。 更多信息可以查看 <a href="https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009247">Information Property List Key Reference</a> 的 <a href="https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW33">NSAppTransportSecurity</a></p><h3 id="nscopying-相关行为">NSCopying 相关行为</h3><p>会话和任务对象都遵循 <a href="https://developer.apple.com/documentation/foundation/nscopying?language=objc">NSCopying</a> 协议：</p><ul><li>当你复制一个会话或者任务对象时，你得到的是相同的对象<li>当你复制一个配置对象时，你得到的是一个新的可以独立修改的对象</ul><h3 id="线程安全">线程安全</h3><p>URLSession 的 API 都是线程安全的，你可以在不同的线程中创建会话和任务。当你的 delegate 调用对应的方法时，任务会自动安排在正确的 delegate 队列上。</p><h2 id="nsurlrequest">NSURLRequest</h2><p><code class="language-plaintext highlighter-rouge">NSURLRequest</code> 封装了加载请求的两个必要属性：加载所需要的 URL 和加载策略。同时，URLRequest 还包括 HTTP 方法（GET ， POST 等）和 HTTP 头。最后，可以通过自定义属性来实现自定义协议。</p><h3 id="预留的-http-头部属性">预留的 HTTP 头部属性</h3><p>URL Loading System 会为你处理 HTTP 协议各个方面的配置（HTTP 1.1 持久连接，代理，身份验证等）。作为这个支持的一部分，URL Loading System 会预留以下 HTTP 头部属性：</p><ul><li>Content-Length<li>Authorization<li>Connection<li>Host<li>Proxy-Authenticate<li>Proxy-Authorization<li>WWW-Authenticate</ul><p>如果你设置了其中一个的属性，系统可以会忽略掉你设置的值，或者重写它，或者只是不进行发送。此外，确切的行为可能会随着时间而改变。为避免此类问题，请勿直接设置这些头部属性。</p><p>URL Loading System 会根据请求正文是否具有已知长度来判断是否需要设置 <code class="language-plaintext highlighter-rouge">Content-Length</code> ：</p><ul><li>如果已经知道长度，它就会使用身份传输编码并将 <code class="language-plaintext highlighter-rouge">Content-Length</code> 设置为已知长度。你可以在设置请求正文为 data 对象时看到这种效果<li>如果不知道长度，则使用分块传输编码，并省略 <code class="language-plaintext highlighter-rouge">Content-Length</code> 。将请求正文设置为流时会看到这种效果。</ul><h2 id="上传数据到网站">上传数据到网站</h2><p>很多 app 都与服务器一起工作并支持上传图片或者文档或者上传一些结构化的数据如 JSON 。你可以使用 <a href="https://developer.apple.com/documentation/foundation/nsurlsession?language=objc">NSURLSession</a> 对象来创建 <a href="https://developer.apple.com/documentation/foundation/nsurlsessionuploadtask?language=objc">NSURLSessionUploadTask</a> 对象。上传任务会使用 <a href="https://developer.apple.com/documentation/foundation/urlrequest?language=objc">URLRequest</a> 来展示如何执行上传任务。</p><h3 id="准备好需要上传的数据">准备好需要上传的数据</h3><p>上传的数据可以是文件的一部分，流，data 。</p><p>很多 Web 服务都支持 JSON 格式的数据，你可以使用 <a href="https://developer.apple.com/documentation/foundation/jsonencoder?language=objc">JSONEncoder</a> 来 <a href="https://developer.apple.com/documentation/swift/encodable?language=objc">Encodable</a> 如数组，字典类型。如下面代码所示，你可以声明一个遵循 <a href="https://developer.apple.com/documentation/swift/codable?language=objc">Codable</a> 协议的结构体，创建一个对象，然后使用 <code class="language-plaintext highlighter-rouge">JSONEncoder</code> 来将其编码成 JSON 数据。</p><pre><code class="language-Swift">struct Order: Codable {
    let customerId: String
    let items: [String]
}

// ...

let order = Order(customerId: "12345",
                  items: ["Cheese pizza", "Diet soda"])
guard let uploadData = try? JSONEncoder().encode(order) else {
    return
}
</code></pre><p>还有其他很多方式来创建数据对象，如将图片编码成 JPEG 或者 PNG 数据，或者将字符串编码成 UTF-8 数据。</p><h3 id="配置上传请求">配置上传请求</h3><p>上传任务需要一个 <code class="language-plaintext highlighter-rouge">URLRequest</code> 对象，需要根据服务器的支持和要求将设置 <a href="https://developer.apple.com/documentation/foundation/urlrequest/2011415-httpmethod?language=objc">httpMethod</a> 为 <code class="language-plaintext highlighter-rouge">POST</code> 或 <code class="language-plaintext highlighter-rouge">PUT</code> 。使用 <a href="https://developer.apple.com/documentation/foundation/urlrequest/2011447-setvalue?language=objc">setValue(_:forHTTPHeaderField:)</a> 方法可以设置 HTTP 头部任何属性，除了 <code class="language-plaintext highlighter-rouge">Content-Length</code> 。会话会根据你的数据大小自动计算出 <code class="language-plaintext highlighter-rouge">Content-Length</code> 。</p><div lang="swift" class="language-swift highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">let</span> <span class="nv">url</span> <span class="o">=</span> <span class="kt">URL</span><span class="p">(</span><span class="nv">string</span><span class="p">:</span> <span class="s">"https://example.com/post"</span><span class="p">)</span><span class="o">!</span>
<span class="k">var</span> <span class="nv">request</span> <span class="o">=</span> <span class="kt">URLRequest</span><span class="p">(</span><span class="nv">url</span><span class="p">:</span> <span class="n">url</span><span class="p">)</span>
<span class="n">request</span><span class="o">.</span><span class="n">httpMethod</span> <span class="o">=</span> <span class="s">"POST"</span>
<span class="n">request</span><span class="o">.</span><span class="nf">setValue</span><span class="p">(</span><span class="s">"application/json"</span><span class="p">,</span> <span class="nv">forHTTPHeaderField</span><span class="p">:</span> <span class="s">"Content-Type"</span><span class="p">)</span>
</pre></table></code></div></div><h3 id="创建和启动上传任务">创建和启动上传任务</h3><p>结合配置好的数据和请求，调用会话的 <a href="https://developer.apple.com/documentation/foundation/nsurlsession/1411518-uploadtaskwithrequest?language=objc">uploadTaskWithRequest:fromData:completionHandler:</a> 方法来创建上传任务对象 <a href="https://developer.apple.com/documentation/foundation/nsurlsessiontask?language=objc">NSURLSessionTask</a> 。任务开始时是挂起状态，所以需要调用 <a href="https://developer.apple.com/documentation/foundation/nsurlsessiontask/1411121-resume?language=objc">resume</a> 方法来启动任务。</p><div lang="swift" class="language-swift highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="k">let</span> <span class="nv">task</span> <span class="o">=</span> <span class="kt">URLSession</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">uploadTask</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">request</span><span class="p">,</span> <span class="nv">from</span><span class="p">:</span> <span class="n">uploadData</span><span class="p">)</span> <span class="p">{</span> <span class="n">data</span><span class="p">,</span> <span class="n">response</span><span class="p">,</span> <span class="n">error</span> <span class="k">in</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nv">error</span> <span class="o">=</span> <span class="n">error</span> <span class="p">{</span>
        <span class="nf">print</span> <span class="p">(</span><span class="s">"error: </span><span class="se">\(</span><span class="n">error</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="k">guard</span> <span class="k">let</span> <span class="nv">response</span> <span class="o">=</span> <span class="n">response</span> <span class="k">as?</span> <span class="kt">HTTPURLResponse</span><span class="p">,</span>
        <span class="p">(</span><span class="mi">200</span><span class="o">...</span><span class="mi">299</span><span class="p">)</span><span class="o">.</span><span class="nf">contains</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">statusCode</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nf">print</span> <span class="p">(</span><span class="s">"server error"</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nv">mimeType</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">mimeType</span><span class="p">,</span>
        <span class="n">mimeType</span> <span class="o">==</span> <span class="s">"application/json"</span><span class="p">,</span>
        <span class="k">let</span> <span class="nv">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">,</span>
        <span class="k">let</span> <span class="nv">dataString</span> <span class="o">=</span> <span class="kt">String</span><span class="p">(</span><span class="nv">data</span><span class="p">:</span> <span class="n">data</span><span class="p">,</span> <span class="nv">encoding</span><span class="p">:</span> <span class="o">.</span><span class="n">utf8</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">print</span> <span class="p">(</span><span class="s">"got data: </span><span class="se">\(</span><span class="n">dataString</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">task</span><span class="o">.</span><span class="nf">resume</span><span class="p">()</span>
</pre></table></code></div></div><h3 id="替代方案设置-delegate">替代方案：设置 delegate</h3><p>可以通过给会话设置 delegate ，然后接入 <code class="language-plaintext highlighter-rouge">NSURLSessionDelegate</code> 和 <code class="language-plaintext highlighter-rouge">NSURLSessionTaskDelegate</code> 协议的方法来处理服务器返回的数据或者传输错误。</p><h2 id="上传流数据">上传流数据</h2><p>流媒体和长期运行的 app 使用持续流来上传数据，而不是发送单个数据或者文件。你可以配置一个 <a href="https://developer.apple.com/documentation/foundation/nsurlsessionuploadtask?language=objc">NSURLSessionUploadTask</a> 对象（ <a href="https://developer.apple.com/documentation/foundation/nsurlsessiontask?language=objc">NSURLSessionTask</a> 子类）来与你提供的流进行工作，然后不定地填充流。</p><p>任务通过会话的 delegate 来获取流，所以你需要创建会话和设置会话的 delegate 。</p><h3 id="创建会话">创建会话</h3><p>创建会话时设置 delegate 和配置。</p><pre><code class="language-Swift">lazy var session: URLSession = URLSession(configuration: .default,
                                          delegate: self,
                                          delegateQueue: .main)
</code></pre><h3 id="创建流上传任务">创建流上传任务</h3><p>调用 <a href="https://developer.apple.com/documentation/foundation/nsurlsession?language=objc">NSURLSession</a> 的 <a href="https://developer.apple.com/documentation/foundation/nsurlsession/1410934-uploadtaskwithstreamedrequest?language=objc">uploadTaskWithStreamedRequest:</a> 来创建流上传任务。</p><div lang="swift" class="language-swift highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">let</span> <span class="nv">url</span> <span class="o">=</span> <span class="kt">URL</span><span class="p">(</span><span class="nv">string</span><span class="p">:</span> <span class="s">"http://127.0.0.1:12345"</span><span class="p">)</span><span class="o">!</span>
<span class="k">var</span> <span class="nv">request</span> <span class="o">=</span> <span class="kt">URLRequest</span><span class="p">(</span><span class="nv">url</span><span class="p">:</span> <span class="n">url</span><span class="p">,</span>
                         <span class="nv">cachePolicy</span><span class="p">:</span> <span class="o">.</span><span class="n">reloadIgnoringLocalCacheData</span><span class="p">,</span>
                         <span class="nv">timeoutInterval</span><span class="p">:</span> <span class="mi">10</span><span class="p">)</span>
<span class="n">request</span><span class="o">.</span><span class="n">httpMethod</span> <span class="o">=</span> <span class="s">"POST"</span>
<span class="k">let</span> <span class="nv">uploadTask</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="nf">uploadTask</span><span class="p">(</span><span class="nv">withStreamedRequest</span><span class="p">:</span> <span class="n">request</span><span class="p">)</span>
<span class="n">uploadTask</span><span class="o">.</span><span class="nf">resume</span><span class="p">()</span>
</pre></table></code></div></div><h3 id="使用流的绑定对来提供输入流">使用流的绑定对来提供输入流</h3><p>你可以使用 <a href="https://developer.apple.com/documentation/foundation/nsinputstream?language=objc">NSInputStream</a> 来提供上传任务所需要的流数据。任务读取来自这个流的数据和上传到服务器。</p><p>一个提供数据给输入流的方式是使用流的绑定对。绑定对包含了 <a href="https://developer.apple.com/documentation/foundation/nsoutputstream?language=objc">NSOutputStream</a> ，你可以输入数据到 <code class="language-plaintext highlighter-rouge">NSOutputStream</code> 中。由于绑定对的关系，你输入到 <code class="language-plaintext highlighter-rouge">NSOutputStream</code> 的数据可以在 <code class="language-plaintext highlighter-rouge">NSInputStream</code> 中获取。</p><p><img data-proofer-ignore data-src="/media/a29fb2be-5f7f-4c56-9ef6-4090ecfbae82.png" alt="a29fb2be-5f7f-4c56-9ef6-4090ecfbae82" /></p><p>下面代码展示了一个持有 <code class="language-plaintext highlighter-rouge">NSIntputStream</code> 和 <code class="language-plaintext highlighter-rouge">NSOutputStream</code> 的结构体 <code class="language-plaintext highlighter-rouge">Streams</code> ，使用 <a href="https://developer.apple.com/documentation/foundation/nsstream/1412683-getboundstreamswithbuffersize?language=objc">getBoundStreamsWithBufferSize:inputStream:outputStream:</a> 方法来配置 <code class="language-plaintext highlighter-rouge">NSInputStream</code> 和 <code class="language-plaintext highlighter-rouge">NSOutputStream</code> 。</p><div lang="swift" class="language-swift highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kd">struct</span> <span class="kt">Streams</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">input</span><span class="p">:</span> <span class="kt">InputStream</span>
    <span class="k">let</span> <span class="nv">output</span><span class="p">:</span> <span class="kt">OutputStream</span>
<span class="p">}</span>
<span class="kd">lazy</span> <span class="k">var</span> <span class="nv">boundStreams</span><span class="p">:</span> <span class="kt">Streams</span> <span class="o">=</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">inputOrNil</span><span class="p">:</span> <span class="kt">InputStream</span><span class="p">?</span> <span class="o">=</span> <span class="kc">nil</span>
    <span class="k">var</span> <span class="nv">outputOrNil</span><span class="p">:</span> <span class="kt">OutputStream</span><span class="p">?</span> <span class="o">=</span> <span class="kc">nil</span>
    <span class="kt">Stream</span><span class="o">.</span><span class="nf">getBoundStreams</span><span class="p">(</span><span class="nv">withBufferSize</span><span class="p">:</span> <span class="mi">4096</span><span class="p">,</span>
                           <span class="nv">inputStream</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">inputOrNil</span><span class="p">,</span>
                           <span class="nv">outputStream</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">outputOrNil</span><span class="p">)</span>
    <span class="k">guard</span> <span class="k">let</span> <span class="nv">input</span> <span class="o">=</span> <span class="n">inputOrNil</span><span class="p">,</span> <span class="k">let</span> <span class="nv">output</span> <span class="o">=</span> <span class="n">outputOrNil</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nf">fatalError</span><span class="p">(</span><span class="s">"On return of `getBoundStreams`, both `inputStream` and `outputStream` will contain non-nil streams."</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">// configure and open output stream</span>
    <span class="n">output</span><span class="o">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="k">self</span>
    <span class="n">output</span><span class="o">.</span><span class="nf">schedule</span><span class="p">(</span><span class="nv">in</span><span class="p">:</span> <span class="o">.</span><span class="n">current</span><span class="p">,</span> <span class="nv">forMode</span><span class="p">:</span> <span class="o">.</span><span class="k">default</span><span class="p">)</span>
    <span class="n">output</span><span class="o">.</span><span class="nf">open</span><span class="p">()</span>
    <span class="k">return</span> <span class="kt">Streams</span><span class="p">(</span><span class="nv">input</span><span class="p">:</span> <span class="n">input</span><span class="p">,</span> <span class="nv">output</span><span class="p">:</span> <span class="n">output</span><span class="p">)</span>
<span class="p">}()</span>
</pre></table></code></div></div><p>在创建绑定对时，确保在从输入流读取数据之前，需要指定足够大的缓存区大小，以容纳所有要写入输出流的数据。 设置 <code class="language-plaintext highlighter-rouge">NSOutputStream</code> 对应的 delegate，可以指示接收输出流何时可以接收新数据。</p><h3 id="提供流给上传任务">提供流给上传任务</h3><p>通过 <code class="language-plaintext highlighter-rouge">NSURLSessionTaskDelegate</code> 的 <code class="language-plaintext highlighter-rouge">urlSession:task:needNewBodyStream:</code> 方法可以提供流给上传任务：</p><div lang="swift" class="language-swift highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kd">func</span> <span class="nf">urlSession</span><span class="p">(</span><span class="n">_</span> <span class="nv">session</span><span class="p">:</span> <span class="kt">URLSession</span><span class="p">,</span> <span class="nv">task</span><span class="p">:</span> <span class="kt">URLSessionTask</span><span class="p">,</span>
                <span class="n">needNewBodyStream</span> <span class="nv">completionHandler</span><span class="p">:</span> <span class="kd">@escaping</span> <span class="p">(</span><span class="kt">InputStream</span><span class="p">?)</span> <span class="o">-&gt;</span> <span class="kt">Void</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">completionHandler</span><span class="p">(</span><span class="n">boundStreams</span><span class="o">.</span><span class="n">input</span><span class="p">)</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="当流准备好时写入数据">当流准备好时写入数据</h3><p>当输出流准备好时写入数据到其中。当流准备就绪时，会调用 <code class="language-plaintext highlighter-rouge">NSStreamDelegate</code> 的方法 <a href="https://developer.apple.com/documentation/foundation/nsstreamdelegate/1410079-stream?language=objc">stream:handleEvent:</a> ，当 <code class="language-plaintext highlighter-rouge">eventCode</code> 参数包含 <a href="https://developer.apple.com/documentation/foundation/nsstreamevent/nsstreameventhasspaceavailable?language=objc">NSStreamEventHasSpaceAvailable</a> 时，表示流准备好接收更多数据。</p><p>如果你未准备好写入数据，或者想在自己的周期内写入数据。可以自定义标志来判断是否写入到流中。 当时处理流时，还需要坚持 <code class="language-plaintext highlighter-rouge">eventCode</code> 参数是否包含 <a href="https://developer.apple.com/documentation/foundation/nsstreamevent/nsstreameventerroroccurred?language=objc">NSStreamEventErrorOccurred</a> ，这意味着流任务失败，需要关闭流和禁止上传。</p><div lang="swift" class="language-swift highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kd">func</span> <span class="nf">stream</span><span class="p">(</span><span class="n">_</span> <span class="nv">aStream</span><span class="p">:</span> <span class="kt">Stream</span><span class="p">,</span> <span class="n">handle</span> <span class="nv">eventCode</span><span class="p">:</span> <span class="kt">Stream</span><span class="o">.</span><span class="kt">Event</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">guard</span> <span class="n">aStream</span> <span class="o">==</span> <span class="n">boundStreams</span><span class="o">.</span><span class="n">output</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">eventCode</span><span class="o">.</span><span class="nf">contains</span><span class="p">(</span><span class="o">.</span><span class="n">hasSpaceAvailable</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">canWrite</span> <span class="o">=</span> <span class="kc">true</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">eventCode</span><span class="o">.</span><span class="nf">contains</span><span class="p">(</span><span class="o">.</span><span class="n">errorOccurred</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Close the streams and alert the user that the upload failed.</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>当你处理 <a href="https://developer.apple.com/documentation/foundation/nsstreamevent/nsstreameventhasspaceavailable?language=objc">NSStreamEventHasSpaceAvailable</a> 事件时，你可以在已经准备好接收更多数据时写入数据到流中。你可以通过调用 <a href="https://developer.apple.com/documentation/foundation/nsoutputstream/1410720-write?language=objc">write:maxLength:</a> 方法来写入数据，需要提供原始数据的引用和可以写入的最大字节数。 下面代码使用了一个计时器来等待 <code class="language-plaintext highlighter-rouge">canWrite</code> 属性为 <code class="language-plaintext highlighter-rouge">true</code> 。如果 <code class="language-plaintext highlighter-rouge">canWrite</code> 为 <code class="language-plaintext highlighter-rouge">true</code> 那么就可以创建一个记录当前日期的字符串，并将其转化成原始字节。然后调用 <a href="https://developer.apple.com/documentation/foundation/nsoutputstream/1410720-write?language=objc">write:maxLength:</a> 方法写入到输出流中。因为输出流已经跟输入流绑定，所以上传任务会自动读取这些字节并发送到目标 URL 中。</p><div lang="swift" class="language-swift highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="n">timer</span> <span class="o">=</span> <span class="kt">Timer</span><span class="o">.</span><span class="nf">scheduledTimer</span><span class="p">(</span><span class="nv">withTimeInterval</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="nv">repeats</span><span class="p">:</span> <span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">[</span><span class="k">weak</span> <span class="k">self</span><span class="p">]</span> <span class="n">timer</span> <span class="k">in</span>
    <span class="k">guard</span> <span class="k">let</span> <span class="nv">self</span> <span class="o">=</span> <span class="k">self</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>

    <span class="k">if</span> <span class="k">self</span><span class="o">.</span><span class="n">canWrite</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">message</span> <span class="o">=</span> <span class="s">"*** </span><span class="se">\(</span><span class="kt">Date</span><span class="p">()</span><span class="se">)\r\n</span><span class="s">"</span>
        <span class="k">guard</span> <span class="k">let</span> <span class="nv">messageData</span> <span class="o">=</span> <span class="n">message</span><span class="o">.</span><span class="nf">data</span><span class="p">(</span><span class="nv">using</span><span class="p">:</span> <span class="o">.</span><span class="n">utf8</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
        <span class="k">let</span> <span class="nv">messageCount</span> <span class="o">=</span> <span class="n">messageData</span><span class="o">.</span><span class="n">count</span>
        <span class="k">let</span> <span class="nv">bytesWritten</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">messageData</span><span class="o">.</span><span class="nf">withUnsafeBytes</span><span class="p">()</span> <span class="p">{</span> <span class="p">(</span><span class="nv">buffer</span><span class="p">:</span> <span class="kt">UnsafePointer</span><span class="o">&lt;</span><span class="kt">UInt8</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">in</span>
            <span class="k">self</span><span class="o">.</span><span class="n">canWrite</span> <span class="o">=</span> <span class="kc">false</span>
            <span class="k">return</span> <span class="k">self</span><span class="o">.</span><span class="n">boundStreams</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="nf">write</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="nv">maxLength</span><span class="p">:</span> <span class="n">messageCount</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">bytesWritten</span> <span class="o">&lt;</span> <span class="n">messageCount</span> <span class="p">{</span>
            <span class="c1">// Handle writing less data than expected.</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><blockquote><p>提示 如果你的数据来自于一个异步处理的流程，例如一个媒体设备的回调，你还是需要等待输出流准备才可以进行写入。在这种情况下，你可以使用一个缓存区来存取你的数据。</p></blockquote><h2 id="下载来自网站的文件">下载来自网站的文件</h2><p>一些以文件形式存储的网络资源，例如图片，文档，你可以使用下载任务来下载它们到本地的文件系统中。</p><h3 id="使用-completion-handler-来创建简单的下载任务">使用 Completion Handler 来创建简单的下载任务</h3><p>你可以使用 <a href="https://developer.apple.com/documentation/foundation/nsurlsession?language=objc">NSURLSession</a> 创建 <a href="https://developer.apple.com/documentation/foundation/nsurlsessiondownloadtask?language=objc">NSURLSessionDownloadTask</a> 来下载文件。如果你在下载时不在乎下载进度或者其它 delegate 回调，你可以使用 completion handler 。不管是完成下载还是发生错误，下载完成时都会调用 completion handler 。</p><p>Completion handler 有可能接收到错误，如无法连接网络。如果没有错误，你有可能接收到 <a href="https://developer.apple.com/documentation/foundation/nsurlresponse?language=objc">NSURLResponse</a> ，你需要检查它来确认接收到的是一个成功的来自服务器的响应。</p><p>如果成功下载，你会接收到一个指示出已下载文件在本地文件系统位置的 URL 。它是临时的，如果你需要永久保存它，在 completion handler 返回前你需要复制或者移动它到其它位置。</p><p>下面代码展示了如何使用通过 completion handler 来创建下载任务，以及如何验证错误，保存结果。</p><div lang="swift" class="language-swift highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="k">let</span> <span class="nv">downloadTask</span> <span class="o">=</span> <span class="kt">URLSession</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">downloadTask</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">url</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">urlOrNil</span><span class="p">,</span> <span class="n">responseOrNil</span><span class="p">,</span> <span class="n">errorOrNil</span> <span class="k">in</span>
    <span class="c1">// check for and handle errors:</span>
    <span class="c1">// * errorOrNil should be nil</span>
    <span class="c1">// * responseOrNil should be an HTTPURLResponse with statusCode in 200..&lt;299</span>
    
    <span class="k">guard</span> <span class="k">let</span> <span class="nv">fileURL</span> <span class="o">=</span> <span class="n">urlOrNil</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
    <span class="k">do</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">documentsURL</span> <span class="o">=</span> <span class="k">try</span>
            <span class="kt">FileManager</span><span class="o">.</span><span class="k">default</span><span class="o">.</span><span class="nf">url</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="o">.</span><span class="n">documentDirectory</span><span class="p">,</span>
                                    <span class="nv">in</span><span class="p">:</span> <span class="o">.</span><span class="n">userDomainMask</span><span class="p">,</span>
                                    <span class="nv">appropriateFor</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span>
                                    <span class="nv">create</span><span class="p">:</span> <span class="kc">false</span><span class="p">)</span>
        <span class="k">let</span> <span class="nv">savedURL</span> <span class="o">=</span> <span class="n">documentsURL</span><span class="o">.</span><span class="nf">appendingPathComponent</span><span class="p">(</span>
            <span class="n">fileUrl</span><span class="o">.</span><span class="n">lastPathComponent</span><span class="p">)</span>
        <span class="k">try</span> <span class="kt">FileManager</span><span class="o">.</span><span class="k">default</span><span class="o">.</span><span class="nf">moveItem</span><span class="p">(</span><span class="nv">at</span><span class="p">:</span> <span class="n">fileUrl</span><span class="p">,</span> <span class="nv">to</span><span class="p">:</span> <span class="n">savedURL</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">{</span>
        <span class="nf">print</span> <span class="p">(</span><span class="s">"file error: </span><span class="se">\(</span><span class="n">error</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">downloadTask</span><span class="o">.</span><span class="nf">resume</span><span class="p">()</span>
</pre></table></code></div></div><h3 id="使用-delegate-来接收进度更新">使用 delegate 来接收进度更新</h3><p>使用 delegate 可以接收下载进度更新，你可以接入 <a href="https://developer.apple.com/documentation/foundation/nsurlsessiontaskdelegate?language=objc">NSURLSessionTaskDelegate</a> 和 <a href="https://developer.apple.com/documentation/foundation/nsurlsessiondownloaddelegate?language=objc">NSURLSessionDownloadDelegate</a> 协议的方法。</p><pre><code class="language-Swift">private lazy var urlSession = URLSession(configuration: .default,
                                         delegate: self,
                                         delegateQueue: nil)
private func startDownload(url: URL) {
    let downloadTask = urlSession.downloadTask(with: url)
    downloadTask.resume()
    self.downloadTask = downloadTask
}
</code></pre><h3 id="接收进度更新">接收进度更新</h3><p>当下载开始执行后，你可以通过 <a href="https://developer.apple.com/documentation/foundation/nsurlsessiondownloaddelegate/1409408-urlsession?language=objc">URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite:</a> 定期接收到进度更新。你可以通过字节计数来更新 app 中的进度 UI 。</p><p>下面代码展示了如何计算下载进度，因为回调是在不确定的 GCD 队列中执行的，所以你需要明确指定在主队列中执行 UI 更新。</p><div lang="swift" class="language-swift highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kd">func</span> <span class="nf">urlSession</span><span class="p">(</span><span class="n">_</span> <span class="nv">session</span><span class="p">:</span> <span class="kt">URLSession</span><span class="p">,</span>
                <span class="nv">downloadTask</span><span class="p">:</span> <span class="kt">URLSessionDownloadTask</span><span class="p">,</span>
                <span class="n">didWriteData</span> <span class="nv">bytesWritten</span><span class="p">:</span> <span class="kt">Int64</span><span class="p">,</span>
                <span class="nv">totalBytesWritten</span><span class="p">:</span> <span class="kt">Int64</span><span class="p">,</span>
                <span class="nv">totalBytesExpectedToWrite</span><span class="p">:</span> <span class="kt">Int64</span><span class="p">)</span> <span class="p">{</span>
     <span class="k">if</span> <span class="n">downloadTask</span> <span class="o">==</span> <span class="k">self</span><span class="o">.</span><span class="n">downloadTask</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">calculatedProgress</span> <span class="o">=</span> <span class="kt">Float</span><span class="p">(</span><span class="n">totalBytesWritten</span><span class="p">)</span> <span class="o">/</span> <span class="kt">Float</span><span class="p">(</span><span class="n">totalBytesExpectedToWrite</span><span class="p">)</span>
        <span class="kt">DispatchQueue</span><span class="o">.</span><span class="n">main</span><span class="o">.</span><span class="n">async</span> <span class="p">{</span>
            <span class="k">self</span><span class="o">.</span><span class="n">progressLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="k">self</span><span class="o">.</span><span class="n">percentFormatter</span><span class="o">.</span><span class="nf">string</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span>
                <span class="kt">NSNumber</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="n">calculatedProgress</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><blockquote><p>提示 如果你只是使用 <a href="https://developer.apple.com/documentation/uikit/uiprogressview?language=objc">UIProgressView</a> 来更新进度 UI ，那么你可以将任务的 <a href="https://developer.apple.com/documentation/foundation/nsurlsessiontask/2908821-progress?language=objc">progress</a> 属性设置给 <code class="language-plaintext highlighter-rouge">UIProgressView</code> 的 <a href="https://developer.apple.com/documentation/uikit/uiprogressview/1619840-observedprogress?language=objc">observedProgress</a> 属性即可，不需要自己计算进度。</p></blockquote><h3 id="在-delegate中处理下载错误">在 delegate中处理下载错误</h3><p>在 <a href="https://developer.apple.com/documentation/foundation/nsurlsessiondownloaddelegate/1411575-urlsession?language=objc">URLSession:downloadTask:didFinishDownloadingToURL:</a> 方法中需要进行判断文件是否存在，响应码是否正确，和对文件进行移动。</p><div lang="swift" class="language-swift highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kd">func</span> <span class="nf">urlSession</span><span class="p">(</span><span class="n">_</span> <span class="nv">session</span><span class="p">:</span> <span class="kt">URLSession</span><span class="p">,</span>
                <span class="nv">downloadTask</span><span class="p">:</span> <span class="kt">URLSessionDownloadTask</span><span class="p">,</span>
                <span class="n">didFinishDownloadingTo</span> <span class="nv">location</span><span class="p">:</span> <span class="kt">URL</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// check for and handle errors:</span>
    <span class="c1">// * downloadTask.response should be an HTTPURLResponse with statusCode in 200..&lt;299</span>

    <span class="k">do</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">documentsURL</span> <span class="o">=</span> <span class="k">try</span>
            <span class="kt">FileManager</span><span class="o">.</span><span class="k">default</span><span class="o">.</span><span class="nf">url</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="o">.</span><span class="n">documentDirectory</span><span class="p">,</span>
                                    <span class="nv">in</span><span class="p">:</span> <span class="o">.</span><span class="n">userDomainMask</span><span class="p">,</span>
                                    <span class="nv">appropriateFor</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span>
                                    <span class="nv">create</span><span class="p">:</span> <span class="kc">false</span><span class="p">)</span>
        <span class="k">let</span> <span class="nv">savedURL</span> <span class="o">=</span> <span class="n">documentsURL</span><span class="o">.</span><span class="nf">appendingPathComponent</span><span class="p">(</span>
            <span class="n">location</span><span class="o">.</span><span class="n">lastPathComponent</span><span class="p">)</span>
        <span class="k">try</span> <span class="kt">FileManager</span><span class="o">.</span><span class="k">default</span><span class="o">.</span><span class="nf">moveItem</span><span class="p">(</span><span class="nv">at</span><span class="p">:</span> <span class="n">location</span><span class="p">,</span> <span class="nv">to</span><span class="p">:</span> <span class="n">savedURL</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">{</span>
        <span class="c1">// handle filesystem error</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>如果有错误产生，就会调用 delegate 的 <a href="https://developer.apple.com/documentation/foundation/nsurlsessiontaskdelegate/1411610-urlsession?language=objc">URLSession:task:didCompleteWithError:</a> 方法。</p><h2 id="暂停和重启下载">暂停和重启下载</h2><p>应用或者用户有时候可能需要取消正在进行的下载，然后再继续进行下载，通过支持断点续传下载，你可以节省用户的时间和流量。</p><p>同样可以借助这个技术来恢复因失去连接而被中断的下载任务。</p><h3 id="取消下载时存储恢复时需要的数据">取消下载时存储恢复时需要的数据</h3><p>你可以通过调用 <a href="https://developer.apple.com/documentation/foundation/nsurlsessiondownloadtask?language=objc">NSURLSessionDownloadTask</a> 的 <a href="https://developer.apple.com/documentation/foundation/nsurlsessiondownloadtask/1411634-cancelbyproducingresumedata?language=objc">cancelByProducingResumeData:</a> 方法来取消任务，当完成取消时会调用 completion handler ，而 completion handler 会接收到一个 <code class="language-plaintext highlighter-rouge">resumeData</code> 参数。如果它不为空，它就是你恢复下载时所需要用的 token ，需要将它存储起来。</p><div lang="swift" class="language-swift highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">downloadTask</span><span class="o">.</span><span class="n">cancel</span> <span class="p">{</span> <span class="n">resumeDataOrNil</span> <span class="k">in</span>
    <span class="k">guard</span> <span class="k">let</span> <span class="nv">resumeData</span> <span class="o">=</span> <span class="n">resumeDataOrNil</span> <span class="k">else</span> <span class="p">{</span> 
      <span class="c1">// download can't be resumed; remove from UI if necessary</span>
      <span class="k">return</span>
    <span class="p">}</span>
    <span class="k">self</span><span class="o">.</span><span class="n">resumeData</span> <span class="o">=</span> <span class="n">resumeData</span>
<span class="p">}</span>
</pre></table></code></div></div><p>只有以下几种形式的任务可以恢复：</p><ul><li>从你第一次请求起，资源没有做任何改动<li>任务是 HTTP 或者 HTTPS 的 GET 请求<li>服务器提供 ETag 或者 Last-Modified 在响应头重<li>服务器支持指定字节范围的请求<li>临时文件未被系统删除</ul><h3 id="下载失败时存储恢复时需要的数据">下载失败时存储恢复时需要的数据</h3><p>你还可以恢复由于暂时失去网络连接而失败的下载任务，如用户离开 WiFi 范围。</p><p>当下载失败时，会话会调用 delegate 的 <a href="https://developer.apple.com/documentation/foundation/nsurlsessiontaskdelegate/1411610-urlsession?language=objc">URLSession:task:didCompleteWithError:</a> 方法，如果 error 不为空，那么就检查 userInfo 中 <a href="https://developer.apple.com/documentation/foundation/nsurlsessiondownloadtaskresumedata?language=objc">NSURLSessionDownloadTaskResumeData</a> 字段是否有数据，如果有，就把对应的数据存储起来，用于恢复下载任务，如果没有，则表示下载任务是不可恢复的。</p><div lang="swift" class="language-swift highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kd">func</span> <span class="nf">urlSession</span><span class="p">(</span><span class="n">_</span> <span class="nv">session</span><span class="p">:</span> <span class="kt">URLSession</span><span class="p">,</span> <span class="nv">task</span><span class="p">:</span> <span class="kt">URLSessionTask</span><span class="p">,</span> <span class="n">didCompleteWithError</span> <span class="nv">error</span><span class="p">:</span> <span class="kt">Error</span><span class="p">?)</span> <span class="p">{</span>
    <span class="k">guard</span> <span class="k">let</span> <span class="nv">error</span> <span class="o">=</span> <span class="n">error</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// Handle success case.</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="k">let</span> <span class="nv">userInfo</span> <span class="o">=</span> <span class="p">(</span><span class="n">error</span> <span class="k">as</span> <span class="kt">NSError</span><span class="p">)</span><span class="o">.</span><span class="n">userInfo</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nv">resumeData</span> <span class="o">=</span> <span class="n">userInfo</span><span class="p">[</span><span class="kt">NSURLSessionDownloadTaskResumeData</span><span class="p">]</span> <span class="k">as?</span> <span class="kt">Data</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">resumeData</span> <span class="o">=</span> <span class="n">resumeData</span>
    <span class="p">}</span> 
    <span class="c1">// Perform any other error handling.</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="使用已保存的恢复用的数据来恢复下载任务">使用已保存的恢复用的数据来恢复下载任务</h3><p>当需要恢复下载任务时，使用 <a href="https://developer.apple.com/documentation/foundation/nsurlsession?language=objc">NSURLSession</a> 的 <a href="https://developer.apple.com/documentation/foundation/nsurlsession/1411598-downloadtaskwithresumedata?language=objc">downloadTaskWithResumeData:completionHandler:</a> 或者 <a href="https://developer.apple.com/documentation/foundation/nsurlsession/1409226-downloadtaskwithresumedata?language=objc">downloadTaskWithResumeData:</a> 方法来创建一个新的 <code class="language-plaintext highlighter-rouge">NSURLSessionDownloadTask</code> ，同时需要使用之前存储的 <code class="language-plaintext highlighter-rouge">resumeData</code> 作为初始化参数。</p><div lang="swift" class="language-swift highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">guard</span> <span class="k">let</span> <span class="nv">resumeData</span> <span class="o">=</span> <span class="n">resumeData</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// inform the user the download can't be resumed</span>
    <span class="k">return</span>
<span class="p">}</span>
<span class="k">let</span> <span class="nv">downloadTask</span> <span class="o">=</span> <span class="n">urlSession</span><span class="o">.</span><span class="nf">downloadTask</span><span class="p">(</span><span class="nv">withResumeData</span><span class="p">:</span> <span class="n">resumeData</span><span class="p">)</span>
<span class="n">downloadTask</span><span class="o">.</span><span class="nf">resume</span><span class="p">()</span>
<span class="k">self</span><span class="o">.</span><span class="n">downloadTask</span> <span class="o">=</span> <span class="n">downloadTask</span>
</pre></table></code></div></div><p>如果下载任务成功恢复，任务会调用 delegate 的 <a href="https://developer.apple.com/documentation/foundation/nsurlsessiondownloaddelegate/1408142-urlsession?language=objc">URLSession:downloadTask:didResumeAtOffset:expectedTotalBytes:</a> 方法。你可以使用 <code class="language-plaintext highlighter-rouge">offset</code> 和 <code class="language-plaintext highlighter-rouge">byte</code> 计数参数来通知用户下载已经恢复，而且有保存之前的进度。</p><h2 id="在后台下载文件">在后台下载文件</h2><p>在你的 app 不活跃时创建任务来下载文件。 对于那些需要较长时间和不紧急的传输任务，你可以使用 <code class="language-plaintext highlighter-rouge">background</code> 创建和运行。任务会在 app 被退到后台时运行，在 app 变为活跃时可以获取已下载的文件。</p><h3 id="创建后台会话">创建后台会话</h3><p>为了执行后台下载，需要使用 <code class="language-plaintext highlighter-rouge">background</code> 操作来配置 <a href="https://developer.apple.com/documentation/foundation/nsurlsession?language=objc">NSURLSession</a> 。</p><ol><li>通过 <code class="language-plaintext highlighter-rouge">NSURLSession</code> 的类方法 <a href="https://developer.apple.com/documentation/foundation/nsurlsessionconfiguration/1407496-backgroundsessionconfigurationwi?language=objc">backgroundSessionConfigurationWithIdentifier:</a> 创建一个后台 <a href="https://developer.apple.com/documentation/foundation/nsurlsessionconfiguration?language=objc">NSURLSessionConfiguration</a> 对象，会话 ID 在 app 里是唯一的。但是大多数 app 只需要很少的后台会话（通常只有一个），你可以把会话 ID 写死。<li>为了在任务完成时让系统唤醒你的 app，需要设置 <a href="https://developer.apple.com/documentation/foundation/nsurlsessionconfiguration/1617174-sessionsendslaunchevents?language=objc">sessionSendsLaunchEvents</a> 为 <code class="language-plaintext highlighter-rouge">true</code> 。<li>对于一些不需要立即完成的任务，可以设置 <a href="https://developer.apple.com/documentation/foundation/nsurlsessionconfiguration/1411552-discretionary?language=objc">discretionary</a> 为 <code class="language-plaintext highlighter-rouge">true</code> ，这样系统可以等待到最佳状态来执行传输，如等到设备充电或者连接到 Wi-Fi 。<li>使用 <code class="language-plaintext highlighter-rouge">NSURLSessionConfiguration</code> 对象来创建 <code class="language-plaintext highlighter-rouge">NSURLSession</code> 对象。</ol><pre><code class="language-Swift">private lazy var urlSession: URLSession = {
    let config = URLSessionConfiguration.background(withIdentifier: "MySession")
    config.isDiscretionary = true
    config.sessionSendsLaunchEvents = true
    return URLSession(configuration: config, delegate: self, delegateQueue: nil)
}()
</code></pre><h3 id="创建和调用下载任务">创建和调用下载任务</h3><p>你可以通过 <a href="https://developer.apple.com/documentation/foundation/nsurlsession/1411482-downloadtaskwithurl?language=objc">downloadTaskWithURL:</a> 或者 <a href="https://developer.apple.com/documentation/foundation/nsurlsession/1411481-downloadtaskwithrequest?language=objc">downloadTaskWithRequest:</a> 方法来创建下载任务。</p><ol><li>使用 <code class="language-plaintext highlighter-rouge">downloadTaskWithURL:</code> 来创建下载任务。<li>也可以通过设置 <a href="https://developer.apple.com/documentation/foundation/nsurlsessiontask/2873413-earliestbegindate?language=objc">earliestBeginDate</a> 来在未来某个时间启动下载任务。设置了之后，下载任务并不是一定会在这个时间启动，只是不会早于这个时间。<li>为了使得系统的网络调度更有效率，可以设置 <a href="https://developer.apple.com/documentation/foundation/nsurlsessiontask/2873401-countofbytesclientexpectstosend?language=objc">countOfBytesClientExpectsToSend</a> 和 <a href="https://developer.apple.com/documentation/foundation/nsurlsessiontask/2873414-countofbytesclientexpectstorecei?language=objc">countOfBytesClientExpectsToReceive</a> 属性。通过设置这些属性，可以设置请求的字节数的上限。<li>调用 <a href="https://developer.apple.com/documentation/foundation/nsurlsessiontask/1411121-resume?language=objc">resume</a> 来启动任务。</ol><div lang="swift" class="language-swift highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">let</span> <span class="nv">backgroundTask</span> <span class="o">=</span> <span class="n">urlSession</span><span class="o">.</span><span class="nf">downloadTask</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">url</span><span class="p">)</span>
<span class="n">backgroundTask</span><span class="o">.</span><span class="n">earliestBeginDate</span> <span class="o">=</span> <span class="kt">Date</span><span class="p">()</span><span class="o">.</span><span class="nf">addingTimeInterval</span><span class="p">(</span><span class="mi">60</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span>
<span class="n">backgroundTask</span><span class="o">.</span><span class="n">countOfBytesClientExpectsToSend</span> <span class="o">=</span> <span class="mi">200</span>
<span class="n">backgroundTask</span><span class="o">.</span><span class="n">countOfBytesClientExpectsToReceive</span> <span class="o">=</span> <span class="mi">500</span> <span class="o">*</span> <span class="mi">1024</span>
<span class="n">backgroundTask</span><span class="o">.</span><span class="nf">resume</span><span class="p">()</span>
</pre></table></code></div></div><h3 id="处理-app-被暂停的情况">处理 App 被暂停的情况</h3><p>App 不同的状态会影响 app 跟后台下载任务的交互。在 iOS ，app 有前台，挂起和被系统终止几种状态， <a href="https://developer.apple.com/documentation/uikit/app_and_environment/managing_your_app_s_life_cycle?language=objc">Managing Your App’s Life Cycle</a> 有更详细的介绍。 当 app 在后台，下载是在另外一个进程执行时，系统可能会挂起 app 。下载完成后，系统恢复 app ，然后调用 <a href="https://developer.apple.com/documentation/uikit/uiapplicationdelegate?language=objc">UIApplicationDelegate</a> 的 <a href="https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1622941-application?language=objc">application:handleEventsForBackgroundURLSession:completionHandler:</a> 方法。 这个方法会传一个 completion handler 作为最后的参数。你需要把这个 handler 存储到 app 中。</p><div lang="swift" class="language-swift highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kd">func</span> <span class="nf">application</span><span class="p">(</span><span class="n">_</span> <span class="nv">application</span><span class="p">:</span> <span class="kt">UIApplication</span><span class="p">,</span>
                 <span class="n">handleEventsForBackgroundURLSession</span> <span class="nv">identifier</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span>
                 <span class="nv">completionHandler</span><span class="p">:</span> <span class="kd">@escaping</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Void</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">backgroundCompletionHandler</span> <span class="o">=</span> <span class="n">completionHandler</span>
<span class="p">}</span>
</pre></table></code></div></div><p>当所有项目都完成传送，系统会调用 <a href="https://developer.apple.com/documentation/foundation/nsurlsessiondelegate?language=objc">NSURLSessionDelegate</a> 的 <a href="https://developer.apple.com/documentation/foundation/nsurlsessiondelegate/1617185-urlsessiondidfinisheventsforback?language=objc">URLSessionDidFinishEventsForBackgroundURLSession:</a> 方法，在这个例子中，我们需要调用之前存储的 <code class="language-plaintext highlighter-rouge">backgroundCompletionHandler</code> 。 <code class="language-plaintext highlighter-rouge">URLSessionDidFinishEventsForBackgroundURLSession:</code> 有可能在子队列中调用，所以需要在主队列中调用：</p><div lang="swift" class="language-swift highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kd">func</span> <span class="nf">urlSessionDidFinishEvents</span><span class="p">(</span><span class="n">forBackgroundURLSession</span> <span class="nv">session</span><span class="p">:</span> <span class="kt">URLSession</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">DispatchQueue</span><span class="o">.</span><span class="n">main</span><span class="o">.</span><span class="n">async</span> <span class="p">{</span>
        <span class="k">guard</span> <span class="k">let</span> <span class="nv">appDelegate</span> <span class="o">=</span> <span class="kt">UIApplication</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="n">delegate</span> <span class="k">as?</span> <span class="kt">AppDelegate</span><span class="p">,</span>
            <span class="k">let</span> <span class="nv">backgroundCompletionHandler</span> <span class="o">=</span>
            <span class="n">appDelegate</span><span class="o">.</span><span class="n">backgroundCompletionHandler</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">return</span>
        <span class="p">}</span>
        <span class="nf">backgroundCompletionHandler</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="获取文件或者移动到永久的地址">获取文件，或者移动到永久的地址</h3><p>一旦你的 app 调用 completion handler ，下载任务就已经完成它的工作，然后调用 delegate 的 <a href="https://developer.apple.com/documentation/foundation/nsurlsessiondownloaddelegate/1411575-urlsession?language=objc">URLSession:downloadTask:didFinishDownloadingToURL:</a> 方法。在这个例子中，文件是已经完全下载了，在你的 delegate 方法返回前都可以获取到。如果你只需要一次读取它，你可以直接通过临时地址直接获取文件。如果你想要保存文件，就需要把它移动到永久的地址。比如 Documents 目录，像 <a href="https://developer.apple.com/documentation/foundation/url_loading_system/downloading_files_from_websites?language=objc">Downloading Files from Websites</a> 描述那样。</p><h3 id="app-被杀死后重新创建任务">App 被杀死后重新创建任务</h3><p>如果系统在 app 被挂起时杀死 app ，系统会在后台重启 app 。作为你启动时步骤的一部分，使用相同的会话 ID 重新创建后台会话，这样使得系统可以通过你的任务来重新连接任务。不管 app 是通过用户还是系统登录都可以进行此操作。一旦 app 重新启动，这一系列的任务跟 app 被挂起然后恢复时一样，像之前讨论的处理 App 被暂停的情况类似。</p><h3 id="遵守后台的传输限制">遵守后台的传输限制</h3><p>在后台会话中，实际的转移是通过与你 app 的流程不同的流程执行的。由于重新启动应用程序的流程相当昂贵，因此某些功能不可用，因此受到以下限制：</p><ul><li>必须要提供 delegate 给会话来传递事件。<li>只支持 HTTP 和 HTTPS 协议（不支持自定义协议）。<li>始终遵循重定向。即使你引入 <a href="https://developer.apple.com/documentation/foundation/nsurlsessiontaskdelegate/1411626-urlsession?language=objc">URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:</a> 方法，也不会进行调用。<li>只支持文件的上传任务（data 对象的上传或者流会在 app 退出时失败）。</ul><h3 id="高效地使用后台会话">高效地使用后台会话</h3><p>当系统恢复或者重新启动你的 app 时，它会使用速率限制器来防止滥用后台下载。当你的 app 在后台开启一个新的下载任务时，任务会等到延迟到期才开始。每当系统恢复或重新启动你的 app 时，延迟的时间都会增加。 因此，如果你的 app 开始一次后台下载任务，然后在下载完成时恢复 app ，启动一个新的下载任务，它会大大增加延迟时间。一个有效的替代方案时是使用一小部分的后台会话（最好是一个），然后使用这些会话来一次性启动多个下载任务。这样使得系统可以一次执行多个下载任务，且在下载完成后恢复 app 。 请记住每个任务都有它自己的开销。如果你发现你在启动时需要执行几千个下载任务，请考虑修改你的设计来执行次数更少，数据更大的传输。</p><blockquote><p>当用户将你的 app 切换到前台时，延迟时间会被重置为 0 。如果延迟时间过去后系统仍没有恢复或者重启你的 app ，延迟时间也会被重置。</p></blockquote><h2 id="获取缓存数据">获取缓存数据</h2><p>控制 URL 请求来如何使用缓存数据 URL Loading System 缓存响应的数据到内存和硬盘中，借此来提升性能和减少网络传输时间。 可以使用 <a href="https://developer.apple.com/documentation/foundation/nsurlcache?language=objc">NSURLCache</a> 类来缓存网络响应的资源。你可以通过 <code class="language-plaintext highlighter-rouge">URLCache</code> 的 <code class="language-plaintext highlighter-rouge">sharedURLCache</code> 来获取缓存的单例，也可以创建自己需要的缓存，给你的 <a href="https://developer.apple.com/documentation/foundation/nsurlsessionconfiguration?language=objc">NSURLSessionConfiguration</a> 对象设置特定的缓存。</p><h3 id="设置-url-请求的缓存策略">设置 URL 请求的缓存策略</h3><p>每个 <a href="https://developer.apple.com/documentation/foundation/urlrequest?language=objc">URLRequest</a> 都包含一个 <a href="https://developer.apple.com/documentation/foundation/urlrequest/cachepolicy?language=objc">URLRequest.CachePolicy</a> 来指示如何执行缓存。你可以通过改变这个策略来控制请求的缓存。 为了方便， <a href="https://developer.apple.com/documentation/foundation/nsurlsessionconfiguration?language=objc">NSURLSessionConfiguration</a> 提供了一个 <a href="https://developer.apple.com/documentation/foundation/nsurlsessionconfiguration/1411655-requestcachepolicy?language=objc">requestCachePolicy</a> 属性，所有通过这个配置发起的请求都会继承这个请求策略。只缓存 HTTP 和 HTTPS 的响应数据。</p><h3 id="直接获取缓存">直接获取缓存</h3><p>你可以通过 URLSession 对象的 <a href="https://developer.apple.com/documentation/foundation/nsurlsession/1411477-configuration?language=objc">configuration</a> 属性的 URLCache 属性来获取或者设置 URLSession 的缓存对象。 通过 <a href="https://developer.apple.com/documentation/foundation/nsurlcache/1411817-cachedresponseforrequest?language=objc">cachedResponseForRequest:</a> 方法可以查找 Request 对应的缓存。如果有对应的缓存数据，就会返回 <a href="https://developer.apple.com/documentation/foundation/nscachedurlresponse?language=objc">NSCachedURLResponse</a> ，否则返回 nil 。 你可以通过缓存来查询资源的占用情况。 <a href="https://developer.apple.com/documentation/foundation/nsurlcache/1407771-currentdiskusage?language=objc">currentDiskUsage</a> 和 <a href="https://developer.apple.com/documentation/foundation/nsurlcache/1413505-diskcapacity?language=objc">diskCapacity</a> 表示缓存使用的文件系统资源，而 <a href="https://developer.apple.com/documentation/foundation/nsurlcache/1408199-currentmemoryusage?language=objc">currentMemoryUsage</a> 和 <a href="https://developer.apple.com/documentation/foundation/nsurlcache/1409781-memorycapacity?language=objc">memoryCapacity</a> 则表示了内存占用。 你可以通过 <a href="https://developer.apple.com/documentation/foundation/nsurlcache/1415377-removecachedresponseforrequest?language=objc">removeCachedResponseForRequest:</a> 方法来移除特定的缓存，也可以通过 <a href="https://developer.apple.com/documentation/foundation/nsurlcache/1415231-removecachedresponsessincedate?language=objc">removeCachedResponsesSinceDate:</a> 来移除指定日期之后的缓存，也可以使用 <a href="https://developer.apple.com/documentation/foundation/nsurlcache/1417802-removeallcachedresponses?language=objc">removeAllCachedResponses</a> 方法来移除所有缓存。</p><h3 id="通过代码管理缓存">通过代码管理缓存</h3><p>你可以通过调用 <a href="https://developer.apple.com/documentation/foundation/nsurlcache/1410340-storecachedresponse?language=objc">storeCachedResponse:forRequest:</a> 方法，提供 CachedURLResponse和 URLRequest 对象来直接写入缓存中。 通常情况下，你可以在 URLSessionTask 对象处理响应时管理响应的缓存。为了在每个响应的基础上管理缓存，需要实现 <a href="https://developer.apple.com/documentation/foundation/nsurlsessiondatadelegate?language=objc">NSURLSessionDataDelegate</a> 协议的 <a href="https://developer.apple.com/documentation/foundation/nsurlsessiondatadelegate/1411612-urlsession?language=objc">URLSession:dataTask:willCacheResponse:completionHandler:</a> 方法。这个方法只在上传和数据任务时调用，后台会话和临时配置不会调用。 这个方法提供了两个参数，CachedURLResponse 对象和 completion handler ，你必须在方法中直接调用 completion handler ：</p><ul><li>可以直接使用提供的 CachedURLResponse 对象进行缓存；<li>nil ，不进行缓存；<li>重新创建一个 CachedURLResponse 对象，结合提供的 CachedURLResponse 对象，同时也可以指定 <a href="https://developer.apple.com/documentation/foundation/nscachedurlresponse/1412269-storagepolicy?language=objc">storagePolicy</a> 和 <a href="https://developer.apple.com/documentation/foundation/nscachedurlresponse/1411900-userinfo?language=objc">userInfo</a></ul><div lang="swift" class="language-swift highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">func</span> <span class="nf">urlSession</span><span class="p">(</span><span class="n">_</span> <span class="nv">session</span><span class="p">:</span> <span class="kt">URLSession</span><span class="p">,</span> <span class="nv">dataTask</span><span class="p">:</span> <span class="kt">URLSessionDataTask</span><span class="p">,</span>
                <span class="n">willCacheResponse</span> <span class="nv">proposedResponse</span><span class="p">:</span> <span class="kt">CachedURLResponse</span><span class="p">,</span>
                <span class="nv">completionHandler</span><span class="p">:</span> <span class="kd">@escaping</span> <span class="p">(</span><span class="kt">CachedURLResponse</span><span class="p">?)</span> <span class="o">-&gt;</span> <span class="kt">Void</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">proposedResponse</span><span class="o">.</span><span class="n">response</span><span class="o">.</span><span class="n">url</span><span class="p">?</span><span class="o">.</span><span class="n">scheme</span> <span class="o">==</span> <span class="err">“</span><span class="n">https</span><span class="err">”</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">updatedResponse</span> <span class="o">=</span> <span class="kt">CachedURLResponse</span><span class="p">(</span><span class="nv">response</span><span class="p">:</span> <span class="n">proposedResponse</span><span class="o">.</span><span class="n">response</span><span class="p">,</span>
                                                <span class="nv">data</span><span class="p">:</span> <span class="n">proposedResponse</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                                                <span class="nv">userInfo</span><span class="p">:</span> <span class="n">proposedResponse</span><span class="o">.</span><span class="n">userInfo</span><span class="p">,</span>
                                                <span class="nv">storagePolicy</span><span class="p">:</span> <span class="o">.</span><span class="n">allowedInMemoryOnly</span><span class="p">)</span>
        <span class="nf">completionHandler</span><span class="p">(</span><span class="n">updatedResponse</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nf">completionHandler</span><span class="p">(</span><span class="n">proposedResponse</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="处理身份认证">处理身份认证</h2><p>当服务器对某个 URL 请求需要进行身份证验证时，做出适当的响应。 当你的 app 通过 <a href="https://developer.apple.com/documentation/foundation/nsurlsessiontask?language=objc">NSURLSessionTask</a> 发起请求时，服务器可能会在继续前以一个或者多个的验证要求进行响应。会话任务会尝试处理。如果处理不了，则会调用会话的 <a href="https://developer.apple.com/documentation/foundation/nsurlsession/1411530-delegate?language=objc">delegate</a> 来进行处理。 为了处理服务器发起的验证请求，你需要实现本文中描述的 delegate 方法。如果你未实现 delegate 对应的方法，那么服务器可能会拒绝你的请求，并且你收到的响应将带有 401 HTTP 状态码（禁止），而不是你期望的数据。</p><h3 id="确定适当的-delegate-方法">确定适当的 delegate 方法</h3><p>接入 delegate 两个或者其中一个验证方法，取决于你接收到的验证要求的性质。</p><ul><li>接入 <a href="https://developer.apple.com/documentation/foundation/nsurlsessiondelegate?language=objc">NSURLSessionDelegate</a> 的 <a href="https://developer.apple.com/documentation/foundation/nsurlsessiondelegate/1409308-urlsession?language=objc">URLSession:didReceiveChallenge:completionHandler:</a> 的方法来处理会话层级的验证要求。它跟 TLS 验证类似。一旦你成功处理这些验证要求，就会影响到所有通过这个会话 <a href="https://developer.apple.com/documentation/foundation/nsurlsession?language=objc">NSURLSession</a> 创建的任务<li>接入 <a href="https://developer.apple.com/documentation/foundation/nsurlsessiontaskdelegate?language=objc">NSURLSessionTaskDelegate</a> <a href="https://developer.apple.com/documentation/foundation/nsurlsessiontaskdelegate/1411595-urlsession?language=objc">URLSession:task:didReceiveChallenge:completionHandler:</a> 的方法来处理任务特定的验证要求。这些要求跟输入用户名/密码验证类似。每个会话都有可能需要进行验证请求。</ul><blockquote><p><a href="https://developer.apple.com/documentation/foundation/nsurlprotectionspace/nsurlprotectionspace_authentication_method_constants?language=objc">NSURLProtectionSpace Authentication Method Constants</a> 中有说明用于会话或者任务认证的方法。</p></blockquote><p>作为一个简单的例子，想象一下当你请求一个受到 HTTP 的基础认证保护的 URL 请求时（像 <a href="https://tools.ietf.org/html/rfc7617">RFC 7617</a> 定义的那样）。因为它是任务层级的认证挑战，所以你需要引入 <a href="https://developer.apple.com/documentation/foundation/nsurlsessiontaskdelegate/1411595-urlsession?language=objc">URLSession:task:didReceiveChallenge:completionHandler:</a> 方法来进行处理。</p><blockquote><p>如果你使用 HTTPS 进行连接，你还会接受到服务器信任的挑战。 <a href="https://developer.apple.com/documentation/foundation/url_loading_system/handling_an_authentication_challenge/performing_manual_server_trust_authentication?language=objc">Performing Manual Server Trust Authentication</a> 有提供更多信息来处理这种会话层级的挑战</p></blockquote><p><img data-proofer-ignore data-src="/media/df4288af-90f3-4504-b657-a5ae9b3e994b.png" alt="df4288af-90f3-4504-b657-a5ae9b3e994b" /></p><h3 id="判断认证挑战的类型">判断认证挑战的类型</h3><p>当你接收到一个认证挑战，使用你的 delegate 方法来判断挑战的类型。delegate 方法会接收一个 <a href="https://developer.apple.com/documentation/foundation/nsurlauthenticationchallenge?language=objc">NSURLAuthenticationChallenge</a> 对象。它描述了正在使用的认证挑战。它包含一个 <a href="https://developer.apple.com/documentation/foundation/nsurlauthenticationchallenge/1410012-protectionspace?language=objc">protectionSpace</a> 属性，而 <a href="https://developer.apple.com/documentation/foundation/nsurlauthenticationchallenge/1410012-protectionspace?language=objc">protectionSpace</a> 属性又包含一个 <a href="https://developer.apple.com/documentation/foundation/nsurlprotectionspace/1415028-authenticationmethod?language=objc">authenticationMethod</a> 属性来指明认证挑战的类型（如一个需要用户名和密码的请求，或者客户端证书）。你可以使用这个值来判断你是否可以处理这个认证挑战。</p><p>你可以通过调用传递过来的 completion handler 来响应认证挑战。你需要传递一个 <a href="https://developer.apple.com/documentation/foundation/nsurlsessionauthchallengedisposition?language=objc">NSURLSessionAuthChallengeDisposition</a> 参数来表示你如何处理这个认证挑战的。你可以使用这个 disposition 参数来提供证书，取消请求或者进行默认的处理方式。</p><ul class="task-list"><li class="task-list-item" hide-bullet><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />下面代码展示了如何根据 <code class="language-plaintext highlighter-rouge">authMethod</code> 来处理认证挑战，如果是 <code class="language-plaintext highlighter-rouge">NSURLAuthenticationMethodHTTPBasic</code> ，就使用默认的处理方法。</ul><div lang="swift" class="language-swift highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">let</span> <span class="nv">authMethod</span> <span class="o">=</span> <span class="n">challenge</span><span class="o">.</span><span class="n">protectionSpace</span><span class="o">.</span><span class="n">authenticationMethod</span>
<span class="k">guard</span> <span class="n">authMethod</span> <span class="o">==</span> <span class="kt">NSURLAuthenticationMethodHTTPBasic</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nf">completionHandler</span><span class="p">(</span><span class="o">.</span><span class="n">performDefaultHandling</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
    <span class="k">return</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="创建证书对象">创建证书对象</h3><p>为了成功响应认证挑战，你需要根据认证挑战的类型来提交一个合适的证书。对于 HTTP 基础和 HTTP 摘要的认证挑战，你需要提供用户名和密码。下面代码展示了一个辅助类如何生成一个由用户输入的 <a href="https://developer.apple.com/documentation/foundation/nsurlcredential?language=objc">NSURLCredential</a> 对象。</p><div lang="swift" class="language-swift highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kd">func</span> <span class="nf">credentialsFromUI</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">URLCredential</span><span class="p">?</span> <span class="p">{</span>
    <span class="k">guard</span> <span class="k">let</span> <span class="nv">username</span> <span class="o">=</span> <span class="n">usernameField</span><span class="o">.</span><span class="n">text</span><span class="p">,</span> <span class="o">!</span><span class="n">username</span><span class="o">.</span><span class="n">isEmpty</span><span class="p">,</span>
        <span class="k">let</span> <span class="nv">password</span> <span class="o">=</span> <span class="n">passwordField</span><span class="o">.</span><span class="n">text</span><span class="p">,</span> <span class="o">!</span><span class="n">password</span><span class="o">.</span><span class="n">isEmpty</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">nil</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kt">URLCredential</span><span class="p">(</span><span class="nv">user</span><span class="p">:</span> <span class="n">username</span><span class="p">,</span> <span class="nv">password</span><span class="p">:</span> <span class="n">password</span><span class="p">,</span>
                         <span class="nv">persistence</span><span class="p">:</span> <span class="o">.</span><span class="n">forSession</span><span class="p">)</span>
<span class="p">}</span>
</pre></table></code></div></div><p>在这个例子中，返回的 <code class="language-plaintext highlighter-rouge">NSURLCredential</code> 包含 <a href="https://developer.apple.com/documentation/foundation/nsurlcredentialpersistence/nsurlcredentialpersistenceforsession?language=objc">NSURLCredentialPersistenceForSession</a> 的持久化属性，所以它只存储在 <code class="language-plaintext highlighter-rouge">NSURLSession</code> 对象中，由这个对象创建的任务也包含对应的 <code class="language-plaintext highlighter-rouge">URLCredential</code> 。</p><h3 id="调用-completion-handler">调用 Completion handler</h3><p>一旦你创建了证书对象，你需要调用 completion handler 来响应挑战。</p><ul><li>如果你无法创建证书，或者用户明确地取消了，调用 completion handler 和传递 <a href="https://developer.apple.com/documentation/foundation/nsurlsessionauthchallengedisposition/nsurlsessionauthchallengecancelauthenticationchallenge?language=objc">NSURLSessionAuthChallengeCancelAuthenticationChallenge</a> 参数。<li>如果你创建了证书对象，调用 completion handler 和传递 <a href="https://developer.apple.com/documentation/foundation/nsurlsessionauthchallengedisposition/nsurlsessionauthchallengeusecredential?language=objc">NSURLSessionAuthChallengeUseCredential</a> 参数。</ul><div lang="swift" class="language-swift highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">guard</span> <span class="k">let</span> <span class="nv">credential</span> <span class="o">=</span> <span class="n">credentialOrNil</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nf">completionHandler</span><span class="p">(</span><span class="o">.</span><span class="n">cancelAuthenticationChallenge</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
    <span class="k">return</span>
<span class="p">}</span>
<span class="nf">completionHandler</span><span class="p">(</span><span class="o">.</span><span class="n">useCredential</span><span class="p">,</span> <span class="n">credential</span><span class="p">)</span>
</pre></table></code></div></div><p>如果你创建的证书被服务器接受，任务就会开始上传和下载数据。</p><h3 id="优雅地处理错误">优雅地处理错误</h3><p>当服务器拒绝你的证书时，系统会再次调用你的 delegate 方法。<code class="language-plaintext highlighter-rouge">NSURLAuthenticationChallenge</code> 的 <a href="https://developer.apple.com/documentation/foundation/nsurlauthenticationchallenge/1417749-proposedcredential?language=objc">proposedCredential</a> 属性即所提供的证书，同时 <a href="https://developer.apple.com/documentation/foundation/nsurlauthenticationchallenge/1416522-previousfailurecount?language=objc">previousFailureCount</a> 表示证书请求失败的次数。你可以根据这些属性来判断下一步怎么处理。</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/code/'>Code</a>, <a href='/categories/ios/'>iOS</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/ios/" class="post-tag no-text-decoration" >iOS</a> <a href="/tags/%E7%BF%BB%E8%AF%91/" class="post-tag no-text-decoration" >翻译</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=https://dirtmelon.github.io/posts/url-loading-system/-loading-system - Dirtmelon&url=https://dirtmelon.github.io/posts/url-loading-system/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=https://dirtmelon.github.io/posts/url-loading-system/-loading-system - Dirtmelon&u=https://dirtmelon.github.io/posts/url-loading-system/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=https://dirtmelon.github.io/posts/url-loading-system/-loading-system - Dirtmelon&url=https://dirtmelon.github.io/posts/url-loading-system/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/iglistkit-first/">IGListKit - 开篇</a><li><a href="/posts/iglistkit-second/">IGListKit 的基石 - IGListSectionController</a><li><a href="/posts/iglistkit-third/">IGListKit 的管理者 - IGListAdapter</a><li><a href="/posts/cocoapods-sync-githooks/">一种使用 CocoaPods 同步 Git hooks 的方案</a><li><a href="/posts/cocoapods-first/">CocoaPods 学习记录 - 官方文档</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/ios/">iOS</a> <a class="post-tag" href="/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">阅读笔记</a> <a class="post-tag" href="/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">源码解析</a> <a class="post-tag" href="/tags/swift/">Swift</a> <a class="post-tag" href="/tags/%E7%BF%BB%E8%AF%91/">翻译</a> <a class="post-tag" href="/tags/summary/">summary</a> <a class="post-tag" href="/tags/algorithm/">Algorithm</a> <a class="post-tag" href="/tags/network/">Network</a> <a class="post-tag" href="/tags/texture/">Texture</a> <a class="post-tag" href="/tags/cocoapods/">CocoaPods</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/texture-basic-concepts/"><div class="card-body"> <span class="timeago small" > Feb 19, 2019 <i class="unloaded">2019-02-19T11:44:10+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Texture-基本概念</h3><div class="text-muted small"><p> 原文：Core Concepts Texture 基本单位为 node ， ASDisplayNode 是建立在 UIView 上的抽象层，如同 UIView 与 CALayer 的关系。ASDiplayNode 是线程安全的，你可以在后台线程进行初始化和配置。 Nodes Node 的用法跟 UIView 类似，且 Node 提供了 UIView 和 CALayer 属性。 Tex...</p></div></div></a></div><div class="card"> <a href="/posts/texture-layout/"><div class="card-body"> <span class="timeago small" > Mar 3, 2019 <i class="unloaded">2019-03-03T00:28:40+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Texture-Layout</h3><div class="text-muted small"><p> 原文链接：Layout 原因和收益 Auto Layout 在处理复杂的 View 时，消耗会指数级上升， Texture 布局在以下几方面比 Auto Layout 好： 快，明显比 Auto Layout 快，基本上跟手动布局差不多 异步和并发，布局可以在后台线程进行计算，所以不会打断用户交互 声明式布局，不可变的数据结构，这使得布局代码易于开发，编写文档，code re...</p></div></div></a></div><div class="card"> <a href="/posts/how-to-manage-image-resources/"><div class="card-body"> <span class="timeago small" > Dec 8, 2016 <i class="unloaded">2016-12-08T15:28:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>图片资源的管理方式</h3><div class="text-muted small"><p> 在开发app的过程中少不了要加载app内的图片资源，最简单的写法就是 let image = UIImage(named: "image")! 我们并不希望在加载app内图片过程中出错，所以都会进行强制解析。但是这样写多了会很乱，有可能会拼错，图片资源删除了也要一个个去修改，也不会在编译时就报错。有可能上线了才发现缺失图片资源。 静态属性方式 Yep中采取扩展的方法来处理。 extens...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/xcode-11-adapts-to-ios-13/" class="btn btn-outline-primary" prompt="Older"><p>Xcode 11 与 iOS 13 适配</p></a> <a href="/posts/beauty-of-data-structures-and-algorithms-first/" class="btn btn-outline-primary" prompt="Newer"><p>《数据结构与算法之美》笔记一</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//dirtmelon-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'URL-loading-system'; this.page.url = 'https://dirtmelon.github.io/posts/url-loading-system/'; this.page.identifier = '/posts/url-loading-system/'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2021 <a href="https://twitter.com/Dirt_melon">dirtmelon</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/ios/">iOS</a> <a class="post-tag" href="/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">阅读笔记</a> <a class="post-tag" href="/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">源码解析</a> <a class="post-tag" href="/tags/swift/">Swift</a> <a class="post-tag" href="/tags/%E7%BF%BB%E8%AF%91/">翻译</a> <a class="post-tag" href="/tags/summary/">summary</a> <a class="post-tag" href="/tags/algorithm/">Algorithm</a> <a class="post-tag" href="/tags/network/">Network</a> <a class="post-tag" href="/tags/texture/">Texture</a> <a class="post-tag" href="/tags/cocoapods/">CocoaPods</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://dirtmelon.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script async src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-GZ7JRH6MFN"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-GZ7JRH6MFN'); }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script>
