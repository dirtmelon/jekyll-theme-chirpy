[ { "title": "Objective-C Direct Methods", "url": "/posts/objective-c-direct-methods/", "categories": "", "tags": "Objective-C", "date": "2021-06-22 23:54:00 +0800", "snippet": "Objective-C Direct MethodsClang 13 documentationcommit :Implement attribute((objc_direct)), attribute((objc_direct_me… · llvm/llvm-project@d4e1ba3Clang 13 新增了 objc_direct 声明，对应的 Xcode 版本为 12 。使用 objc_direct 标记的 Objective-C 方法为直接派发方法。 direct 方法在调用时类似于静态方法，降低了一定的性能损耗，但是也牺牲了 Objective-C 的一些特性。direct..." }, { "title": "一种使用 CocoaPods 同步 Git hooks 的方案", "url": "/posts/cocoapods-sync-githooks/", "categories": "Code, Ruby", "tags": "CocoaPods", "date": "2021-05-23 21:19:00 +0800", "snippet": "Git hooks 是什么Git hooks 是一段脚本，可以在 Git 执行某些操作之前或者之后执行，比如说 commit ， push 或者 receive 。随便打开某个 Git 项目的目录，可以在 .git/hooks 这个目录下看到 Git hooks 的示例代码，不过都是以 .sample 后缀结尾，需要把 .sample 去掉后才会生效。Git hooks 可以使用多种语言编写，包括 Shell ， Ruby ， Perl 和 Python 等。如果想要跳过 Git hooks 的检查，可以在执行 Git 命令时添加 —no-verify 参数，那么就算 Git hooks..." }, { "title": "CocoaPods 学习记录 - 官方文档", "url": "/posts/cocoapods-first/", "categories": "Code, Ruby", "tags": "CocoaPods", "date": "2021-03-13 18:12:00 +0800", "snippet": "CocoaPods 的官方文档写得比较详细，建议都过一遍，以免用错方法和漏掉一些可以提高效率的小技巧。pod install vs pod updateCocoaPods Guides - pod install vs. pod update很多人都认为只有在第一次配置 CocoaPods 时才使用 pod install ，后面都是使用 pod update ，然而事实并非如此。TL;DR: 使用 pod install 来下载新的 pods ，即使你已经有 Podfile 且之前已经执行过 pod install 。就算只是给已使用 CocoaPods 的项目添加或者移除 pods..." }, { "title": "IGListKit - 完结篇", "url": "/posts/iglistkit-fifth/", "categories": "Code, Objective-C", "tags": "源码解析", "date": "2021-02-19 14:52:00 +0800", "snippet": "IGListCollectionViewLayoutIGListCollectionViewLayout 其实不太算得上是 IGListKIt 的内容，它主要作用是提供一个可变宽度和高度的流式布局。看下来发现这块写得太好了，从里面可以学到很多如何高效编写一个自定义的 UICollectionViewLayout 的相关技巧。IGListCollectionViewLayout 提供了一些常用的 static 的方法，用于在计算布局时根据滑动方向获取不同的属性，其中一个例子如下：static CGFloat UIEdgeInsetsLeadingInsetInDirection(UIEdg..." }, { "title": "IGListKit 的数据处理 - Updater&amp;Diff", "url": "/posts/iglistkit-fourth/", "categories": "Code, Objective-C", "tags": "源码解析", "date": "2021-01-02 17:30:00 +0800", "snippet": "IGListAdapterUpdater在初始化 IGListAdapter 时提供了一个 id&amp;lt;IGListUpdatingDelegate&amp;gt; updater 参数，调用者可以自己自定义一个支持 IGListUpdatingDelegate 协议的类，来实现 IGListUpdatingDelegate 的方法。 IGListAdapter 在更新 UICollectionView 和数据源时都是通过 updater 来进行操作， IGListKit 为我们提供了一个默认的 updater ： IGListAdapterUpdater ， IGListAda..." }, { "title": "IGListKit 的管理者 - IGListAdapter", "url": "/posts/iglistkit-third/", "categories": "Code, Objective-C", "tags": "源码解析", "date": "2020-12-27 13:53:00 +0800", "snippet": "初始化IGListAdapter 负责处理 UICollectionView 的 DataSource 和 Delegate ，所有 DataSource/Delegate 的相关方法都会在 IGListAdapter 内部消化完毕，调用方只需要设置 IGListAdapter 的 dataSource 和 collectionView 即可， IGListAdapterDataSource 则负责给 IGListAdapter 提供数据源：@protocol IGListAdapterDataSource &amp;lt;NSObject&amp;gt;/// 根据不同的 ad..." }, { "title": "IGListKit 的基石 - IGListSectionController", "url": "/posts/iglistkit-second/", "categories": "Code, Objective-C", "tags": "源码解析", "date": "2020-12-20 09:43:00 +0800", "snippet": "IGListSectionController 跟 Object 是一一对应的关系，在 IGListAdapterDataSource 的 listAdapter:sectionControllerForObject: 方法中，会根据不同的 Object 返回不同的 IGListSectionController 。它跟我们日常理解的 UICollectinoView 的 Section 不同，你无法将 Object 的数组和 IGListSectionController 绑定，如果要将数组绑定到一个 IGListSectionController 中，需要将 Object 的数组..." }, { "title": "IGListKit - 开篇", "url": "/posts/iglistkit-first/", "categories": "Code, Objective-C", "tags": "源码解析", "date": "2020-11-30 16:02:00 +0800", "snippet": "UICollectionView/UITableView作为一个 iOS 开发者，在日常开发中少不了与 UITableView/UICollectionView 打交道。因为复用池的存在，即使在处理大量数据的情况下，它们仍能保持较低的内存占用，而简单的 DataSource/Delegate 设计方式，可以让我们只需要几行代码就可以完成对 UITableView/UICollectionView 数据和交互的相关配置。由于 UITableView 对界面布局的限制，你无法在 UITableView 中自定义布局，比如瀑布流之类的样式。于是苹果在 iOS6.0 中推出了 UICollect..." }, { "title": "《 Web 性能权威指南》阅读笔记 - 无线网络性能", "url": "/posts/high-performance-browser-networking-third/", "categories": "Code, Network", "tags": "阅读笔记, Network", "date": "2020-11-02 17:56:00 +0800", "snippet": "无线网络概览无线网络的性能基础所有无线技术都有自身的约束和局限。然而，无论使用哪种无线技术，所有通信方法都有一个最大的信道容量，这个容量是由相同的底层原理决定的。香农公式： C 是信道容量，单位是 bit/s ； BW 是可用带宽，单位是 Hz ； S 是信号， N 是噪声，单位是 W 。在所有这些因素中，与数据传输速度最直接相关的就是接收端与发送端之间的可用带宽和信号强度。带宽有线网络通过线缆将网络中的各个节点连接起来，而无线电通信本质上则是一个共享媒体，它靠的是无线电波，或者专业一点讲，叫做电磁辐射。为实现通信，发送端与接收端必须事先就通信使用的频率范围达成共识，在这个频率范围..." }, { "title": "《 Web 性能权威指南》阅读笔记-HTTP", "url": "/posts/high-performance-browser-networking-second/", "categories": "Code, Network", "tags": "阅读笔记, Network", "date": "2020-10-26 20:07:00 +0800", "snippet": "HTTP 简史HTTP （ HyperText Transfer Protocol ，超文本传输协议）是互联网上最普遍采用的一种应用协议，也是客户端与服务器之间的共用语言，是现代 Web 的基础。从最初的一个关键字和文档路径开始， HTTP 最终不仅成为了浏览器的协议，而且也几乎成为了所有互联网软件和硬件应用的协议。HTTP 0.9 ：只有一行的协议Tim Berners-Lee 最初的 HTTP 建议是以简洁为出发点设计的，目的是推动他的另一个刚刚萌芽的思想——万维网的应用。事实证明，这个策略非常有效。这个经验也非常值得有抱负的协议设计者汲取。Tim Berners-Lee 概述了这..." }, { "title": "《 Web 性能权威指南》阅读笔记-网络技术概览", "url": "/posts/high-performance-browser-networking-first/", "categories": "Code, Network", "tags": "阅读笔记, Network", "date": "2020-10-18 15:47:28 +0800", "snippet": "延迟与带宽WPO （ Web Performance Optimization ，Web性能优化）产业从无到有，快速增长，充分说明用户越来越重视速度方面的用户体验。速度是关键： 网站越快，用户的黏性越高； 网站越快，用户忠诚度更高； 网站越快，用户转化率越高。不仅限于网站，移动端也是相同的情况。延迟和带宽是影响速度的两个关键因素。延迟是 message 或 packet 从起点到终点经历的时间。这个定义简单明了，但却掩盖了很多有用的信息。事实上，任何系统都有很多因素可能影响传送消息的时间。 传播延迟：消息从发送端到接收端需要的时间，是信号传播距离和速度的函数； 传输延迟：把消息..." }, { "title": "MemorySafety", "url": "/posts/MemorySafety/", "categories": "Code, Swift", "tags": "Swift, 翻译", "date": "2020-09-30 10:15:10 +0800", "snippet": "原文：MemorySafety在默认情况下， Swift 会防止你的代码中发生不安全的行为。举个例子， Swift 保证所有变量在使用前都已经完成了初始化，当它们被释放后无法对内存进行存取，数组的索引越界时报错。Swift 还要求修改内存内容的代码具有独占的访问权限，以此来保证同时对同一区域内存的多次访问不会造成冲突。因为 Swift 会自动管理内存，所以大多数情况下你都不需要考虑有关内存访问的问题。然而，弄明白什么地方有可能发生冲突仍然非常重要，你可以避免写出访问内存时造成冲突的代码。如果你的代码保护这些冲突，那么你会得到一个编译时或者运行时的错误。存取内存时的冲突当你执行像是设置变量..." }, { "title": "Swift 与 Objective-C 互操作中的 Optional", "url": "/posts/Optional-between-Swift-and-Objective-C/", "categories": "Code, Swift", "tags": "Swift, Objective-C", "date": "2020-07-13 23:33:20 +0800", "snippet": "参考 Optionals in Swift Objective-C Interoperability 本文基于 Swift 5.3 和 Xcode 12.0 beta 2 编写，不排除将来可能有变化。nonnull为了与 Swift 的 Optional 类型交互， Objective-C 提供了 nullable ， nonnull 等关键字，用于表示某个属性是否有可能为 nil ，这里是相关说明 Nullability 。假设我们有这么一个 Objective-C 类：#import &amp;lt;UIKit/UIKit.h&amp;gt;NS_ASSUME_NONNULL_BE..." }, { "title": "Moya", "url": "/posts/Moya/", "categories": "Code, Swift", "tags": "源码解析", "date": "2020-07-05 23:53:07 +0800", "snippet": "是什么和为什么通过 Alamofire 可以对 URLSession 进行封装，使我们不需要过多关注一些琐碎的细节。但是在 Alamofire 的上层，我们可能还需要再做一层封装，这层封装针对于我们的 App ，更接近业务层。 Moya 正是对应的这层封装。 一般来说 App 的网络架构可能如下图所示：可能看到加入 Moya 后，整个 App 的网络层功能非常清晰， App 不会直接与 Alamofire 交互，所有网络请求都是通过 Moya 发起。Moya 支持以下特性： 编译时检测是否使用正确的 API endpoint ； 通过 enum 的关联值来对不同的 endpoint..." }, { "title": "Alamofire", "url": "/posts/Alamofire/", "categories": "Code, Swift", "tags": "源码解析", "date": "2020-06-15 22:10:26 +0800", "snippet": "为什么需要一个第三方框架对于大部分 App 来说都需要跟服务器做数据传输，通常情况下都是通过 HTTPS/HTTP 来完成。 URLSession 已经封装得很好，但是如果需要把网络层跟业务层分离开来，我们通常需要基于 URLSession 再做一层封装，对 method ，header ，上传，下载，错误处理等再做一层处理，让业务方在调用的时候更加舒服。Alamofire 是基于 URLSession 进行的封装，使用 Swift 编写的一个优雅的网络框架。本文主要是讲述 Alamofire 的具体逻辑和用法，对应的 Alamofire 版本为 5.2.1 。URLSession 和 ..." }, { "title": "Swift 与指针", "url": "/posts/Swift-and-Pointer/", "categories": "Code, Swift", "tags": "Swift", "date": "2020-05-18 21:27:24 +0800", "snippet": "为什么使用指针Swift 是一门非常安全的语言，强类型，Optinal 都是为了提高安全性所引入的，当我们对一个值为 nil 的 Optional 进行强制解包时就会触发崩溃，这是为了安全而触发的崩溃，可以防止程序有预期之外的行为。如果这里不崩溃，可能导致后续程序行为不可预期。大多数情况下，我们在使用 Swift 时都不需要使用指针，但是在某些情况下我们不可避免地需要使用指针相关 API ： 追求性能，直接操作内存； 与 C 进行交互； 通过修改指针的值来进行数据通讯；但是当我们越过类型的边界，直接对内存进行操作时，所有一切都变得不安全，从严格意义上来说，我们不能确定某个指针所指..." }, { "title": "Apple Keywords", "url": "/posts/Apple-Keywords/", "categories": "Code, iOS", "tags": "iOS", "date": "2020-04-29 23:02:22 +0800", "snippet": "Why熟悉 Apple 提供的一些 Keyword ，在适当的时候使用，有助于写出更规范的接口，也可以提高代码质量。Nullability在 Swift 中可以使用 ? 和 ! 来显式声明一个对象是 optional 还是 non-optional ，但是 Objective-C 中没有这一行为，所有对象都默认是可以设置为 nil 的，在 Swift 与 Objective-C 混编时， Swift 层不知道 Objective-C 层的对象是否为 optional ，它会统一当成 non-optional 来处理。这样导致 Swift 层在调用时有可能对 nil 进行强制解包导致崩溃。..." }, { "title": "Aspects", "url": "/posts/Aspects/", "categories": "Code, Objective-C", "tags": "源码解析", "date": "2020-03-07 17:23:30 +0800", "snippet": "Aspects 好处都有啥在 Objective-C 中可以使用 method swizzling 来进行 AOP 编程，可以替换掉原有方法的执行，或者在原有方法执行前后添加自己的代码。举个最普遍的例子：我们需要统计 app 中每个 ViewController 出现的次数，需要在 viewDidAppear: 中添加统计方法，一般来说我们可能会考虑用继承，但是继承会带来以下两个问题： 需要一个基类来实现这些代码，如果有多个类似的需求则会导致基类非常庞大； 所有新建的 ViewController 都需要继承自这个基类，需要针对不同的 Controller 类型来编写不同的基类；通过..." }, { "title": "《数据结构与算法之美》学习笔记三", "url": "/posts/beauty-of-data-structures-and-algorithms-third/", "categories": "Code, Algorithm", "tags": "阅读笔记, Algorithm", "date": "2020-02-04 20:32:19 +0800", "snippet": "计数排序、桶排序和基数排序三种线性排序算法 计数排序、桶排序与基数排序 - BYVoid 这篇也说得比较好。基于比较的排序有快排，插入排序和选择排序等，基于比较的排序算法是不能突破 O(nlogn) 的。 N个数有N!个可能的排列情况，也就是说基于比较的排序算法的判定树有N!个叶子结点，比较次数至少为log(N!)=O(NlogN)(斯特林公式)。非基于比较的排序，如计数排序，桶排序和基数排序，则有严格的条件限制。 从整体上来说，计数排序，桶排序都是非基于比较的排序算法，而其时间复杂度依赖于数据的范围，桶排序还依赖于空间的开销和数据的分布。而基数排序是一种对多元组排序的有效方法，具体..." }, { "title": "下一个十年", "url": "/posts/2019/", "categories": "Life", "tags": "summary", "date": "2020-01-05 19:28:40 +0800", "snippet": "工作今年十一月份的时候换了份工作，来到了大公司。为什么要换工作呢？从17年4月份加入前司到现在差不多过了两年半，所有东西都非常熟悉了，跟大家也都聊得很开，进入了一个舒适区，但是因为业务上的东西都太熟悉了，日常任务感觉上都是一些比较重复的东西。加上快到年底了，也想出去看看机会，看看自己的技术水平。刚好接到了一个比较不错的 Offer ，也想尝试一下，然后开始重新使用 Objective-C 。为什么要加入创业公司呢？就我个人来说有以下几点优点： 从 0 到 1 搭建一款产品，你可以经历到一款产品从无到有的完整历程，如果是做社交，产品早期的 KOL 你应该都认识的，整个社区对你来说都是有血..." }, { "title": "《数据结构与算法之美》笔记二", "url": "/posts/beauty-of-data-structures-and-algorithms-second/", "categories": "Code, Algorithm", "tags": "阅读笔记, Algorithm", "date": "2020-01-04 21:59:56 +0800", "snippet": "递归Recursion - LeetCode对于重复子问题，可以使用备忘录优化。排序冒泡排序原地排序，稳定的排序算法。冒泡排序算法的运作如下： 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。class Array def bubble_sort! (0...(size - 1)).each do |i| (0...(size - i - 1)..." }, { "title": "《数据结构与算法之美》笔记一", "url": "/posts/beauty-of-data-structures-and-algorithms-first/", "categories": "Code, Algorithm", "tags": "阅读笔记, Algorithm", "date": "2019-12-29 16:18:47 +0800", "snippet": "链表与 LRU 缓存淘汰算法数组与链表在内存分布上的不同之处，数组需要连续的内存空间，链表则不需要。数组与链表的性能比较：LeetCode 上也有对应的题目，146. LRU Cache 。LRU 算法在 iOS 上的应用YYCache 算是一例，通过双向链表结合 NSDictionary 使得增、删、改、查、清空的时间复杂度都是 O(1) 。具体实现代码在 YYMemoryCache.m 这个类里面。练习题：判断链表是否为回文链表Palindrome Linked List - LeetCode如何写出正确的链表代码重点留意边界情况。Linked List - LeetCode栈经典应..." }, { "title": "URL-loading-system", "url": "/posts/url-loading-system/", "categories": "Code, iOS", "tags": "iOS, 翻译", "date": "2019-11-30 16:24:54 +0800", "snippet": " 原文：[URL Loading System Apple Developer Documentation](https://developer.apple.com/documentation/foundation/url_loading_system) 通过标准的互联网协议来与 URL 交流和与服务器通讯。概览URL Loading System 可以获取通过 URL 来辨别的资源，使用如 https 的标准协议或者一些你创造的自定义协议。加载是异步执行的，所以你的应用可以继续响应操作和在返回数据或者错误时进行处理。你可以使用 URLSessi..." }, { "title": "Xcode 11 与 iOS 13 适配", "url": "/posts/xcode-11-adapts-to-ios-13/", "categories": "Code, iOS", "tags": "iOS, Xcode", "date": "2019-10-13 20:00:41 +0800", "snippet": "启动白屏在 iOS 13 以下的版本中，如果你在 App 中替换了 window.rootViewController 那么会有一个 UITransitionView 的界面遗留在 window 上无法释放，苹果并不推荐我们在 App 运行时替换 window.rootViewController 。但是有时业务确实需要我们怎么做，比如只有登录后可以使用 App ，我们可以在登录后替换 window.rootViewController 。但是到了 iOS 13 情况变得不一样了，iOS 13 可能调整了流程，如果移除了 UITransitionView 应用就会白屏，所以需要调整下代码..." }, { "title": "slow-motion-video", "url": "/posts/slow-motion-video/", "categories": "Code, iOS", "tags": "iOS", "date": "2019-09-08 19:21:37 +0800", "snippet": "起因有用户反馈上传慢动作视频后，视频为正常状态的视频，而不是慢动作视频，在视频列表界面中显示的视频时间长度也不正确。打开系统相处进行查看时，显示的视频时间长度也是正常状态的视频时间长度，而不是慢动作状态下的视频时间长度，但是打开播放后就是慢动作视频。系统提供了编辑慢动作视频的功能，可以选择慢动作区域，由此可以推测出，系统存取在相册中的是正常状态下的视频，在播放时在通过视频的对应信息来控制播放的速度。那么如何导出正确的视频资源和显示正确的视频时间呢？播放对应的视频和显示正确的时间播放对应的视频无论播放的视频是什么类型，都是通过 PHAsset 获取到对应的 AVAsset ，然后通过 AV..." }, { "title": "现有工程逐步使用 RxSwift 和 MVVM", "url": "/posts/migrate-to-rxswift-and-mvvm/", "categories": "Code, iOS", "tags": "iOS, RxSwift, MVVM", "date": "2019-09-03 22:32:44 +0800", "snippet": "现状目前项目采用的是 MVC 结构，UIViewController 包含大量代码，包括网络请求，数据处理，布局代码等，难于测试（虽然也不写测试）。随着项目发展，这部分内容会越来越多，越来越复杂，导致 UIViewController 中的代码越来越难维护。为了项目的可持续发展，决定开始开始使用 RxSwift 和 MVVM 。ViewModelViewModel 扮演的是处理业务逻辑的角色，负责处理数据和为 ViewController 提供数据源。一般来说有几下几点要求： 可测试的，这样可以直接为 ViewModel 编写单元测试。 不知道 ViewController 或者 ..." }, { "title": "回字的几种写法 - Pull To Dismiss", "url": "/posts/Pull-To-Dismiss/", "categories": "Code, iOS", "tags": "iOS", "date": "2019-07-13 20:59:48 +0800", "snippet": "有些 App 在弹出评论列表，或者其它界面时，是从底部弹出的，且下拉对应的 ScrollView 也可以触发 dismiss 的动画，不需要去点击按钮，在交互上来说也是连续的。在实现这个需求的过程，我发现这个需求有几种写法，这几种写法都需要先给对应的 ViewController 添加 UIPanGestureRecognizer 手势，只是对手势的处理方法不同，添加手势的方法如下： let panGestureRecognizer = UIPanGestureRecognizer(target: self, ..." }, { "title": "PhotoKit-使用", "url": "/posts/photoKit-usage/", "categories": "Code, iOS", "tags": "iOS", "date": "2019-06-09 22:37:23 +0800", "snippet": "相机胶卷一般情况下我们都希望自定义相册界面时获取到的数据跟系统的相机胶卷数据是一致的。PHAsset 中 有个 fetchAssets(with:options:) 的方法，可以获取到手机中全部的 PHAsset ，但是排序不对，而且系统的相机胶卷其实也是一个相册，所以还是要获取到对应的 PHAssetCollection 。 PHAssetCollection 中有 ` fetchAssetCollections(with:subtype:options:) 方法来获取相册。需要指定 PHAssetCollectionType 和 PHAssetCollectio..." }, { "title": "PhotoKit-概览", "url": "/posts/photokit-overview/", "categories": "Code, iOS", "tags": "iOS", "date": "2019-04-23 14:07:23 +0800", "snippet": "iOS 8 开始提供，分为 Photos 和 Photos UI 两部分。作用： 从用户照片库中获取照片和视频资源，相册 添加，删除和修改资源或相册 编辑照片或者视频的内容或者元数据PhotoKit 对象模型PHObject ，PhotoKit 中的基类，PHAsset ，PHAssetCollection ，PHCollectionList 和 PHObjectPlaceholder 都继承于它，只包含 localIdentifier 这个属性，用于判断是否相等和进行 hash 。PHAsset，PhotoKit 中表示图片或者视频资源的模型，包含了媒体的元数据，如 isFa..." }, { "title": "Texture-Layout", "url": "/posts/texture-layout/", "categories": "Code, iOS", "tags": "iOS, Texture, 翻译", "date": "2019-03-03 00:28:40 +0800", "snippet": "原文链接：Layout原因和收益Auto Layout 在处理复杂的 View 时，消耗会指数级上升，Texture 布局在以下几方面比 Auto Layout 好： 快，明显比 Auto Layout 快，基本上跟手动布局差不多 异步和并发，布局可以在后台线程进行计算，所以不会打断用户交互 声明式布局，不可变的数据结构，这使得布局代码易于开发，编写文档，code review ，测试，debug ，描述和维护 可缓存，得益于不可变的数据结构，布局可以在后台预先计算和缓存起来 可扩展的，代码易于复用受到 CSS Flexbox 的启发这两个系统有非常多相似的属性。也有不同的地方..." }, { "title": "Texture-基本概念", "url": "/posts/texture-basic-concepts/", "categories": "Code, iOS", "tags": "iOS, Texture, 翻译", "date": "2019-02-19 11:44:10 +0800", "snippet": "原文：Core ConceptsTexture 基本单位为 node ， ASDisplayNode 是建立在 UIView 上的抽象层，如同 UIView 与 CALayer 的关系。ASDiplayNode 是线程安全的，你可以在后台线程进行初始化和配置。NodesNode 的用法跟 UIView 类似，且 Node 提供了 UIView 和 CALayer 属性。Texture 提供了丰富的 Node 子类 ，用于取代 UIKit 组建。 ASDipslayNode -&amp;gt; UIView ASCellNode -&amp;gt; UITableViewCell/..." }, { "title": "2018", "url": "/posts/2018/", "categories": "Life", "tags": "summary", "date": "2019-02-10 21:03:10 +0800", "snippet": "工作小程序带来的变化18年上半年公司重点放在小程序上，也因为小程序本身的特性：更新快，无遗留版本的包袱），导致整个开发节奏特别快，当时小程序一般两三天发一个版本，就导致 iOS 这边也必须加快开发节奏，当时也是一直在加班。而且小程序那边有两个开发人员，iOS 这边就我一个，整体感觉就是一个人在干着两个人的活。虽然小程序获客成本比较低，基本上微信用户点一下就成了我们的用户了，但是这样拉过来的用户质量比较低，一般随便看一下就不会再打开了，这也是小程序普遍都是做工具，不是做社区的原因。后来公司也意识到这个问题，逐渐也转移重心到开发原生应用上。大环境的变化上半年一直在找投资，6月份的时候投资人还..." }, { "title": "2018-11-ReadingList", "url": "/posts/2018-11-ReadingList/", "categories": "Code, iOS", "tags": "阅读笔记", "date": "2018-12-05 23:19:27 +0800", "snippet": "A Better MVC, Part 1: The Problems | Dave DeLong问题： 违反封装，充斥着大量面条代码 Massview View Controller解决办法：开发者为了解决上面两个问题通常会使用其它架构方式。但是会增加团队成员的学习成本。系统更新时也有可能需要更多时间来进行适配，同样地，如果你依赖了其它第三库，还需要等得第三库的更新。A Better MVC, Part 2: Fixing Encapsulation | Dave DeLong对 View Controller 进行解耦，View Controller 不需要知道其它 View Co..." }, { "title": "2018-10-ReadingList", "url": "/posts/2018-10-ReadingList/", "categories": "Code, iOS", "tags": "阅读笔记", "date": "2018-11-01 20:58:14 +0800", "snippet": "https://nshipster.cn/hashable/Hash在 swift 中的进化史https://www.appcoda.com/memory-management-swift/strong weak 与 unownedhttps://oleb.net/2018/photos-data-model/PhotoKit 是 iOS 提供给 app 进行相册相关操作的框架，作者从中发现了数据层部分是使用 CoreData 来编写的，讲述如何发现是使用 CreData 以及如何使用 Xcode 结合 .mom 文件来查看 Data Model 的结构https://swiftrock..." }, { "title": "《 App 架构》阅读笔记-笔记1", "url": "/posts/app-architecture-first/", "categories": "Code, iOS", "tags": "阅读笔记, Architecture", "date": "2018-10-29 21:52:04 +0800", "snippet": "由 objc.io 出版的关于 App架构的书，我阅读的是ObjC 中国翻译的中文版本。关于此书此书用一个 录音 app 来实现以下几种设计模式： Model-View-Controller (MVC) Model-View-ViewModel+Coordinator (MVVM-C) Model-View-Controller+ViewState (MVC+VS) ModelAdapter-ViewBinder (MAVB) Elm 架构 (The Elm Architecture, TEA)没有哪种设计模式可以在所有情况下都做到最好，需要根据团队和 app 来进行调整和选择..." }, { "title": "2018-09-ReadingList", "url": "/posts/2018-09-ReadingList/", "categories": "Code, iOS", "tags": "阅读笔记", "date": "2018-10-05 14:05:15 +0800", "snippet": "Swift 4 泛型：如何在你的代码或App里应用泛型如何在 Swift 中应用泛型，比较基础。Swift 中的属性Swift 属性相关说明，一些属性相关的基础用法。Defer usage in Swiftdefer 在 swift 中的运行机制，defer 的执行顺序是按照声明顺序倒序执行，介绍了几个在 swift 中使用 defer 的场景，可以预先设定在函数完成后需要执行的方法。我大部分用到 defer 的场景就是取消 tableView/collectionView 的选中效果。CompactMap vs flatMap: The differences explainedcom..." }, { "title": "2017", "url": "/posts/2017/", "categories": "Life", "tags": "summary", "date": "2018-03-04 23:03:08 +0800", "snippet": "工作2017年在工作上的变动较大，3月初从原来的公司离职，到找了一个月都没有找到工作，到4月份的时候来到现在的一个创业公司。也差不多有一年的时间了。工作方式工作方式变化较大。原来的公司属于半国企那种性质，需求变化也不大，下班也基本上都不会找你聊工作的事，我觉得可能是因为大家可能对产品都不大在乎，做出来就行了。现在几乎将工作和生活完全融合在一起了。一般大家发现什么bug或者有什么需求都会直接在微信上提出来，就算周末也是一样。可能是因为之前太懒散了，我觉得现在还算不错。有点奇怪。而且现在也比较自由，对上下班的时间要求不太严格，能做完需求就行了。12月31号晚上我还在赶一个需求，也是比较独特的..." }, { "title": "Texture 开发笔记", "url": "/posts/texture-notes/", "categories": "Code, iOS", "tags": "iOS, Texture", "date": "2018-01-07 23:51:06 +0800", "snippet": "ASImageNodeASImageNode 不支持直接设置 tintColor ，如果需要设置 tintColor需要通过 imageModificationBlock 进行设置：imageNode.imageModificationBlock = ASImageNodeTintColorModificationBlock(UIColor.white)github上的相关讨论：https://github.com/facebookarchive/AsyncDisplayKit/issues/426还有就是如果需要改变ASButtonNode 的 imageNode 的 tintColo..." }, { "title": "PhotoKit 与 iCloud 图片", "url": "/posts/photokit-with-iCloud/", "categories": "Code, iOS", "tags": "iOS", "date": "2017-10-08 21:53:28 +0800", "snippet": "起因公司的 app 在前段时间的改版中，需要自定义一个相册界面，调研了一轮开源控件，感觉没有找到比较满意的，就尝试自己写了一个，用了 PhotoKit。基本上用下来也没多大问题。但是在处理iCloud图片的时候遇到了一个小问题。如果用户开启了优化 iPhone 存储空间，或者未加载好，PhotoKit 是会先拿到这些图片的缩略图，一般来说在相册列表显示多张图片时，为了防止占用内存过多，通常是调用 requestImage(for:targetSize:contentMode:options:resultHandler:) 来获取指定尺寸的图片资源，这时候如果你的相册列表显示的图片的尺寸..." }, { "title": "《Swift进阶》阅读笔记 - 可选值", "url": "/posts/advanced-swift-optional/", "categories": "Code, Swift", "tags": "Swift, 阅读笔记", "date": "2017-03-14 23:45:17 +0800", "snippet": "哨岗值当返回一个“魔法数”来表示函数没有返回真实的值，这样的值称为“哨岗值”。哨岗值很容易产生问题，因为可能忘记检查哨岗值，并且不小心使用了它们。通过枚举解决魔法数的问题enum Optional&amp;lt;Wrapped&amp;gt; { case none case some(wrapped)}获取关联值的唯一方法是使用 switch 或者 if case 语句。和哨岗值不同，除非你显式地检查并解包，你是不可能意外地使用到一个 Optional 中的值的。var array = [&quot;one&quot;, &quot;two&quot;, &quot;thr..." }, { "title": "《Swift进阶》阅读笔记 - 集合类型", "url": "/posts/advanced-swift-collections/", "categories": "Code, Swift", "tags": "Swift, 阅读笔记", "date": "2017-03-13 22:03:06 +0800", "snippet": "数组高阶函数实现map函数，把for循环中的代码模版部分用一个泛型函数封装起来。下面是可能的实现方式：extension Array { func map&amp;lt;T&amp;gt;(_ transform: (Element) -&amp;gt; T) -&amp;gt; [T] { var result: [T] = [] result.reserveCapacity(count) for x in self { result.append(transform(x)) } return re..." }, { "title": "为什么使用 RxSwift", "url": "/posts/why-use-rxswift/", "categories": "", "tags": "RxSwift, 翻译", "date": "2017-03-09 15:31:00 +0800", "snippet": "原文链接:WhyRxSwift支持以声明的方式来构建App。BindingsObservable.combineLatest(firstName.rx.text, lastName.rx.text) { $0 + &quot; &quot; + $1 } .map { &quot;Greetings, \\($0)&quot; } .bindTo(greetingLabel.rx.text)也适用于UITableView和UICollectionView。viewModel .rows .bindTo(resultsTableView.rx.items(cellId..." }, { "title": "2016", "url": "/posts/2016/", "categories": "Life", "tags": "summary", "date": "2016-12-31 19:08:41 +0800", "snippet": "总结差不多是时候开始新的一年了。没有写过年终总结之类的东西，一直都懒得总结。但是看到前面的一篇说希望以后能多写点东西，那就写一下吧。今年是作为iOS开发者完整渡过的第一年。年初开始的时候是负责写APM类的SDK，其实一开始是有点抗拒的，因为涉及的大多是底层的东西，比较枯燥。后来写着写着发现其实也挺不错的，可以学到很多有趣的东西。再后来发现这其实是个KPI产物，挺无奈的。8月份的时候由于某个项目的开发人员离职两个，于是临时抽调过去开发起App来，开始接触到界面开发的东西，终于可以用Storyboard拖拉控件了。最开心的是用Swfit重写了公司的一个小项目，带薪编译时间多了起来:]。年初的..." }, { "title": "图片资源的管理方式", "url": "/posts/how-to-manage-image-resources/", "categories": "Code, iOS", "tags": "iOS, Swift", "date": "2016-12-08 15:28:00 +0800", "snippet": "在开发app的过程中少不了要加载app内的图片资源，最简单的写法就是let image = UIImage(named: &quot;image&quot;)!我们并不希望在加载app内图片过程中出错，所以都会进行强制解析。但是这样写多了会很乱，有可能会拼错，图片资源删除了也要一个个去修改，也不会在编译时就报错。有可能上线了才发现缺失图片资源。静态属性方式Yep中采取扩展的方法来处理。extension UIImage { static var xxx_image: UIImage { return UIImage(named: &quot;image&quot;)!..." }, { "title": "网速才是第一生产力", "url": "/posts/first/", "categories": "", "tags": "", "date": "2016-07-30 23:03:08 +0800", "snippet": "从 Farbox 转到 Github Pages 了，希望以后可以多写点东西。" } ]
